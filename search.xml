<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 和 Next主题 和 思维导图</title>
    <url>/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[
<div class="markmap-container" style="height:600px; background-color: #F5F5F5">
  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;思维导图&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;使用现有的插件或组件&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;Mermaid：更偏向流程图&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[3,4]},&quot;v&quot;:&quot;Kityminder&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[4,5]},&quot;v&quot;:&quot;1&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[5,6]},&quot;v&quot;:&quot;2&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;找寻相关项目&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;Markmap&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;直接弄，失败&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;使用jsdom，失败&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;寻找现成库，成功&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;现已支持 markdown/链接/等特性&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;&lt;a href=\&quot;https://www.baidu.com\&quot;&gt;links&lt;/a&gt;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;&lt;strong&gt;inline&lt;/strong&gt; &lt;del&gt;text&lt;/del&gt; &lt;em&gt;styles&lt;/em&gt;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[14,16]},&quot;v&quot;:&quot;multiline&lt;br&gt;\ntext&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;&lt;code&gt;inline code&lt;/code&gt;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;Latex：&lt;span class=\&quot;katex\&quot;&gt;&lt;span class=\&quot;katex-mathml\&quot;&gt;&lt;math xmlns=\&quot;http://www.w3.org/1998/Math/MathML\&quot;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;±&lt;/mo&gt;&lt;msqrt&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;/msqrt&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=\&quot;application/x-tex\&quot;&gt;x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&quot;katex-html\&quot; aria-hidden=\&quot;true\&quot;&gt;&lt;span class=\&quot;base\&quot;&gt;&lt;span class=\&quot;strut\&quot; style=\&quot;height:0.43056em;vertical-align:0em;\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;mord mathnormal\&quot;&gt;x&lt;/span&gt;&lt;span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2777777777777778em;\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;mrel\&quot;&gt;=&lt;/span&gt;&lt;span class=\&quot;mspace\&quot; style=\&quot;margin-right:0.2777777777777778em;\&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&quot;base\&quot;&gt;&lt;span class=\&quot;strut\&quot; style=\&quot;height:1.384482em;vertical-align:-0.345em;\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;mord\&quot;&gt;&lt;span class=\&quot;mord\&quot;&gt;&lt;span class=\&quot;mopen nulldelimiter\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;mfrac\&quot;&gt;&lt;span class=\&quot;vlist-t vlist-t2\&quot;&gt;&lt;span class=\&quot;vlist-r\&quot;&gt;&lt;span class=\&quot;vlist\&quot; style=\&quot;height:1.039482em;\&quot;&gt;&lt;span style=\&quot;top:-2.6550000000000002em;\&quot;&gt;&lt;span class=\&quot;pstrut\&quot; style=\&quot;height:3em;\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;sizing reset-size6 size3 mtight\&quot;&gt;&lt;span class=\&quot;mord mtight\&quot;&gt;&lt;span class=\&quot;mord mtight\&quot;&gt;2&lt;/span&gt;&lt;span class=\&quot;mord mathnormal mtight\&quot;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&quot;top:-3.23em;\&quot;&gt;&lt;span class=\&quot;pstrut\&quot; style=\&quot;height:3em;\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;frac-line\&quot; style=\&quot;border-bottom-width:0.04em;\&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&quot;top:-3.3939999999999997em;\&quot;&gt;&lt;span class=\&quot;pstrut\&quot; style=\&quot;height:3em;\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;sizing reset-size6 size3 mtight\&quot;&gt;&lt;span class=\&quot;mord mtight\&quot;&gt;&lt;span class=\&quot;mord mtight\&quot;&gt;−&lt;/span&gt;&lt;span class=\&quot;mord mathnormal mtight\&quot;&gt;b&lt;/span&gt;&lt;span class=\&quot;mbin mtight\&quot;&gt;±&lt;/span&gt;&lt;span class=\&quot;mord sqrt mtight\&quot;&gt;&lt;span class=\&quot;vlist-t vlist-t2\&quot;&gt;&lt;span class=\&quot;vlist-r\&quot;&gt;&lt;span class=\&quot;vlist\&quot; style=\&quot;height:0.9221171428571429em;\&quot;&gt;&lt;span class=\&quot;svg-align\&quot; style=\&quot;top:-3em;\&quot;&gt;&lt;span class=\&quot;pstrut\&quot; style=\&quot;height:3em;\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;mord mtight\&quot; style=\&quot;padding-left:0.833em;\&quot;&gt;&lt;span class=\&quot;mord mtight\&quot;&gt;&lt;span class=\&quot;mord mathnormal mtight\&quot;&gt;b&lt;/span&gt;&lt;span class=\&quot;msupsub\&quot;&gt;&lt;span class=\&quot;vlist-t\&quot;&gt;&lt;span class=\&quot;vlist-r\&quot;&gt;&lt;span class=\&quot;vlist\&quot; style=\&quot;height:0.7463142857142857em;\&quot;&gt;&lt;span style=\&quot;top:-2.786em;margin-right:0.07142857142857144em;\&quot;&gt;&lt;span class=\&quot;pstrut\&quot; style=\&quot;height:2.5em;\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;sizing reset-size3 size1 mtight\&quot;&gt;&lt;span class=\&quot;mord mtight\&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&quot;mbin mtight\&quot;&gt;−&lt;/span&gt;&lt;span class=\&quot;mord mtight\&quot;&gt;4&lt;/span&gt;&lt;span class=\&quot;mord mathnormal mtight\&quot;&gt;a&lt;/span&gt;&lt;span class=\&quot;mord mathnormal mtight\&quot;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&quot;top:-2.882117142857143em;\&quot;&gt;&lt;span class=\&quot;pstrut\&quot; style=\&quot;height:3em;\&quot;&gt;&lt;/span&gt;&lt;span class=\&quot;hide-tail mtight\&quot; style=\&quot;min-width:0.853em;height:1.08em;\&quot;&gt;&lt;svg width=&#39;400em&#39; height=&#39;1.08em&#39; viewBox=&#39;0 0 400000 1080&#39; preserveAspectRatio=&#39;xMinYMin slice&#39;&gt;&lt;path d=&#39;M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&quot;vlist-s\&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=\&quot;vlist-r\&quot;&gt;&lt;span class=\&quot;vlist\&quot; style=\&quot;height:0.11788285714285718em;\&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&quot;vlist-s\&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=\&quot;vlist-r\&quot;&gt;&lt;span class=\&quot;vlist\&quot; style=\&quot;height:0.345em;\&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&quot;mclose nulldelimiter\&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&quot;}]}]}"></svg>
</div>

<p>  hexo-markmap插件按需求修改了 template.js 添加了 background-color
字段。<br />
  hexo-theme-next主题按需求修改了 hexo-generator-searchdb 中的
search.js。<br />
  想让 search.js 修改部分生效，需要引入包 <span class="citation"
data-cites="next-theme/plugins">@next-theme/plugins</span> 并指定 next
主题使用本地的第三方依赖，否则 next 主题会依赖于 cdnjs 。同时注释掉
next主题中 _vendors.yml 里对应插件的 MD5 验证。 <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">CONFIG</span><span class="token punctuation">.</span>localsearch<span class="token punctuation">.</span>param_highlight_keyword<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    url<span class="token punctuation">.</span>searchParams<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">'highlight'</span><span class="token punctuation">,</span> keywords<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></p>
]]></content>
  </entry>
  <entry>
    <title>保留文件</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="留空">留空</h1>
<p>留空 <!--
分布式 是 物理设备 上的划分
微服务 是 逻辑、功能等 上的划分

灰度发布(金丝雀发布)、蓝绿部署
--></p>
]]></content>
  </entry>
  <entry>
    <title>保留文件</title>
    <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<!--
### 分布式时主机间的通信方式  

#### &ensp;&ensp;TCP、UDP  
&ensp;&ensp;最基本的通信方式。二进制传输，其他所有通信方式，**都是建立** 在TCP或UDP之上。

#### &ensp;&ensp;RPC，Remote Procedure Call  
&ensp;&ensp;PRC为远程方法调用。RPC本身是一个 **概念** 。重点是方法的调用，没有对象概念。  

#### &ensp;&ensp;Web Service  
&ensp;&ensp;基于Http + Xml的通信方式。

#### &ensp;&ensp;REST，Representational State Transfer  
&ensp;&ensp;基于Http + JSON的通信方式。

#### &ensp;&ensp;JMS，Java Message Service  
&ensp;&ensp;Java消息服务。将对象在物理意义上传输，相当于将对象，从客户端传输到服务器。

#### &ensp;&ensp;RMI，Remote Method Invocation  
&ensp;&ensp;不能跨语言的Java远程方法调用。RMI也是一种RPC的实现方式。

### RPC
rpc是一种概念、技术思想，有多种实现方式。RPC也可以通过HTTP实现 / http是RPC的一种实现方式。  
RPC是一种概念、技术思想，怎么实现这个概念。有哪些方式可以实现这个概念。  

#### &ensp;&ensp;Dubbo中的RPC

#### &ensp;&ensp;gRPC中的RPC  

### RPC的核心  

#### &ensp;&ensp;&ensp;&ensp;服务暴露和服务发现


#### &ensp;&ensp;&ensp;&ensp;序列化和反序列化  

#### &ensp;&ensp;&ensp;&ensp;网络传输

### 实现了RPC的主流框架 -->
]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>通信方式</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>保留文件</title>
    <url>/%E5%AE%B9%E5%99%A8%E5%8C%96%E7%8E%AF%E5%A2%83/Docker-Effective/</url>
    <content><![CDATA[<!--
Docker 镜像 的 tag 中 : lastest 只是一个 标签，和 其他版本标签没什么不同的。字面上为最新版本，实质上只是镜像的标签名称。当前最新版本除了 用版本号表示，还可以用 lastest 表示。一旦该镜像被拉取到本地，版本号就已经确定，不会自动更新。
lastest标签的镜像 不会随着版本更新 而 自动更新。只是个名字，没有其它附加作用，更不会自动更新。建议直接下载 带版本号的 镜像 更加的直观。


考虑到分布式或微服务，推荐单个容器只运行一个进程，也就是只负责一个功能
docker-engine本质上，相当于 当前的 linux 系统上，创建了一个空间 来 隔离文件。
docker 容器 所需要的 最基础的 linux 内核，就来自于 当前 linux 系统文件。

Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。
因此，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。
Docker Desktop 属于先在虚拟机中安装 Linux 然后再安装 Docker

所以 docker-engine 必须运行在 linux内核 上。
docker容器 相当于 共享的 linux 操作系统资源，像linux内核等，文件做隔离来 实现独立。和 虚拟机做比较的话，就是 虚拟机共享的是 计算机硬件资源，独立的操作系统

docker-desktop 也是在 windos 或 mac 系统中，安装了 linux内核，才能 运行 docker-engine的。

exec 前台交互 进入 运行中的 容器，会创建一个新的容器 bash进程 ，exit 后，删除对应的 bash进程
attach 前台交互 进入 运行中的 容器，不会创建，且 exit后，容器停止。

守护进程在后台运行，dockers容器必须要有一个前台进程才能留存，如果docker容器内的进程在后台运行，那么该容器会自动退出。

文件联合系统 union file system
rootfs
bootfs

docker commit命令 ： 将容器提交成 新镜像；不如直接用 Dockerfile


什么是 bash
什么是 zsh
什么是 shell

--privileged=true 参数

容器数据卷 :
host 和 容器 路径映射：
  rw read write； 
  ro read only 限制 容器 不能 写操作
docker inspect containId
  "Mounts"

Dockerfile：构成 docker image 的文件
  每条 RUN 指令都会创建一个镜像层

  FROM xxx : 将一个已存在的镜像作为基础镜像，新镜像基于该镜像修改；
  RUN : Dockerfile 构成 build 镜像时 执行的命令；
  CMD : 镜像 run 容器时 执行的命令；该 CMD 命令 会被 docker run [OPTIONS] IMAGE [CMD] [ARG...] 的 CMD 覆盖； 
  ENTRYPOINT : 也是命令。当同时出现 ENTRYPOINT 和 CMD 时，优先 ENTRYPOINT作为 命令， CMD 作为 ENTRYPOINT 的参数；

  CMD 和 ENTRYPOINT：

docker build

Dockerfile 和 构建缓存

Dockerfile + jar包 ：
ADD jar包

docker 和 网络

docker compose：
  管理容器，一个配置文件，解决 一个项目 需要的多容器。相当于 避免多次 run容器
  通过 docker-compose 文件，直接启动多个 容器


Portainer：
  轻量级可视化docker工具
CAdvisor + influxDB + Granfana CIG：
  重量级可视化docker工具
-->
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL学习笔记</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql-A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li><h1 id="mysql架构">MySQL架构</h1>
<ul>
<li>连接器：管理连接、验证用户密码、获取用户权限</li>
<li>分析器：SQL语句解析
<ul>
<li>词法分析：识别字符串的命令，识别表名、列名等</li>
<li>语法分析：对词法分析结构进行规则判定</li>
</ul></li>
<li>优化器：多索引时，对采用索引的选择，关联表的连接顺序，SQL条件顺序</li>
<li>执行器：判断用户权限，调用存储引擎接口，处理数据。一条SQL可能涉及到触发器，而触发器涉及的表是否有权限，只能在执行阶段才能判断</li>
</ul></li>
<li><h1 id="事务">事务</h1>
<ul>
<li><h2 id="事务的特性">事务的特性</h2>
<ul>
<li>原子性：</li>
<li>一致性：</li>
<li>隔离性：确保一个事务的执行不会被其他事务干扰。一个事务开启后的写操作，在提交前，对其他事务不可见。受
<strong>隔离级别</strong> 影响。</li>
<li>持久性：</li>
</ul>
<p>  当多个线程开启事务并发操作时，可能会出现：</p>
<ul>
<li>脏读：</li>
<li>不可重复读：</li>
<li>幻读：</li>
</ul></li>
<li><h2 id="事务的隔离级别">事务的隔离级别</h2>
<ul>
<li>读未提交：</li>
<li>读提交：</li>
<li>可重复读：</li>
<li>串行化：在该隔离等级下，事务中的读写操作，系统会自动添加读或写的行锁。所有的读取和写入操作都是串行执行的，每个事务都在独占使用资源。</li>
</ul></li>
<li><h2 id="事务隔离-和-并发控制">事务隔离 和 并发控制</h2>
<p>  在除了 不提交读 的其他隔离级别中，串行化
通过添加锁，来管理数据的并发操作。提交读 和
可重复读需要不通过加锁的方式来管理数据的并发操作。<br />
  并发控制的目的：保证事务的隔离性的实现。当多个事务同时对数据进行读写操作时，需要保证数据的安全、可用、隔离等。通过锁
和 MVCC 两种机制对线程的并发进行管理：</p>
<ul>
<li><h3 id="锁">锁</h3></li>
<li><h3 id="mvcc_多版本并发控制">MVCC_多版本并发控制</h3>
  用于实现 事务隔离性 的一种设计思想。不同的数据库 或 存储引擎 对于 MVCC
的实现不同。</li>
</ul>
<p>  MVCC 和 锁 是两种不同的并发控制设计，但不互斥。</p></li>
<li><h2 id="mvcc-的实现">MVCC 的实现</h2>
<p><strong>每条记录在更新的时候都会同时记录一条回滚操作</strong><br />
InnoDB 在实现 MVCC 时用到的一致性读视图<br />
undo log（回滚日志）<br />
MVCC只在可重复读（REPEATABLE READ）和提交读（READ
COMMITTED）两个隔离级别下工作。</p>
<p>可重复读
隔离级别：视图是在事务启动时创建的，整个事务存在期间都用这个视图。<br />
读提交 隔离级别：视图是在每个 SQL 语句开始执行的时候创建的。<br />
系统里没有比这个回滚日志更早的 视图 的时候。</p></li>
<li><h2 id="视图">视图</h2>
<p>在 MySQL 里，有两个“视图”的概念：<br />
一个是
view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是
create view … ，而它的查询方法与表一样。<br />
另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read
view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable
Read，可重复读）隔离级别的实现。</p></li>
</ul></li>
<li><h1 id="索引">索引</h1>
<p>高数据查询的效率</p>
<ul>
<li><h2 id="主键索引_聚簇索引">主键索引_聚簇索引</h2></li>
<li><h2 id="非主键索引_二级索引">非主键索引_二级索引</h2>
<p>回到主键索引树搜索的过程，我们称为回表</p>
<ul>
<li><h3 id="覆盖索引">覆盖索引</h3>
如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查
ID 的值，而 ID 的值已经在 k
索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引
k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。<br />
由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段</li>
</ul></li>
<li><h2 id="最左前缀原则">最左前缀原则</h2></li>
<li><h2 id="索引下推">索引下推</h2></li>
</ul>
<p>  索引是根据索引定义里面字段的顺序排序的，也就是
<strong>最左前缀原则</strong>
。如联合索引(a，b)就是先根据a排序，然后再根据b排序。因为最左前缀原则，如果再(a，b)上有联合索引，则该索引树中已经按照先a后b的顺序，那么
<strong>没有必要再单独的a上建立索引</strong>
。如果表中主键是(a，b)，现有一个索引c，那没在索引c的树结构中，就是以c的顺序构造树，如果有相同的值，则根据主键先a后b的顺序来构造，相当于先c再a再b。<strong>最左前缀原则可以减少没必要的索引</strong>
，节省空间。<br />
  <strong>最左前缀原则</strong>
针对的是联合索引，可以理解成先后排序。举例说明：联合索引 (a,b,c)
其实在树结构上来看其实 <strong>只有a是有序</strong>
的，b和c是无序的。只有在a是某个确定固定的值时，b才是有序的而此时就c无序。只有a和b都是固定值时，c才是有序的。就是申明索引时的从左到右。<strong>声明一个
(a,b,c) 的联合索引，相当于 有 (a),(a,b),(a,b,c) 三个索引</strong>
。查询语句使用联合索引不符合该原则时，可能就会出现
<strong>索引失效</strong> 。举例说明：假设联合索引 (a,b,c)
，当select语句的 where条件 涉及的字段只有 b,c ，没有 a 时
那么(a,b,c)的索引就无效了，因为对于(a,b,c)索引来说只有a是有序的，只有在a固定的时候b才有序。因此
where条件中 没有a 或者 a使用了范围 (如&gt;,&lt;,!=,%等)
使得a值不固定，那么b也失去了有序的前提条件，(a,b,c)索引也会失效。<br />
  因为 <strong>优化器</strong> 的存在，联合索引的字段在 where条件
中出现的 <strong>顺序是无所谓的</strong> ，如：a = 1 and b = 2 and c = 3
和 c = 3 and b = 2 and a = 1
是一样的都会使用(a,b,c)联合索引。因为使用二级索引可能会发生回表操作，因此使用二级索引然后回表
或者 不使用索引直接全表遍历 这种情况也是由 <strong>优化器</strong>
判断具体使用哪种方法。可以使用 <strong>explain</strong> 来查看 sql语句
执行的情况。<br />
  Mysql
5.6之后，在二级索引遍历过程中，优先对二级索引中包含的字段进行判断，只有判断通过了才回表，这一优化称为
<strong>索引下推</strong> 。如：有二级索引(a,b),然后执行 select * from
table where a = 2 and b = 1 and c = 3；在Mysql
5.6之前，当二级索引找到第一个a=2的叶子节点后，就通过叶子节点的主键值，回表获得主键值所对应的行数据，再判断b和c是否符合。这样每次都回表，开销大。Mysql
5.6后进行优化，会先判定二级索引中包含的字段。也就是先找到第一个a =
2的叶子节点，然后判断二级索引中包含的b是否符合 b =
1，如果符合才回表去获得c的值，如果不符合则跳过下一个。</p></li>
<li><h1 id="mysql的锁机制">MySQL的锁机制</h1>
<ul>
<li><h2 id="根据锁的思想划分">根据锁的思想划分：</h2>
<ul>
<li><h3 id="排他锁">排他锁</h3></li>
<li><h3 id="共享锁">共享锁</h3></li>
</ul></li>
<li><h2 id="根据锁的作用域划分">根据锁的作用域划分：</h2>
<ul>
<li><h3 id="全局锁">全局锁</h3>
<p>  对整个库加 读锁 (Flush Tables With Read
Lock)，所有线程在该库中只能执行读操作。更新数据DML、更新表结构DDL
等操作会被阻塞。一般对整个库做备份时使用。<br />
  对于 innoDB引擎
来说，事务的可重复读隔离级别，能做到开启事务时，得到一个视图。该视图能够保证操作数据的一致，因此没必要使用全局锁。</p></li>
<li><h3 id="表锁">表锁</h3>
<ul>
<li>表数据锁<br />
  对数据加锁</li>
<li>元数据锁，Meta Data Lock<br />
  对表结构加锁</li>
</ul></li>
<li><h3 id="行锁">行锁</h3>
<p>行锁由引擎层实现</p></li>
</ul></li>
<li><h2 id="mvcc">MVCC</h2>
<ul>
<li><h3 id="乐观并发控制">乐观并发控制</h3></li>
<li><h3 id="悲观并发控制">悲观并发控制</h3></li>
</ul></li>
<li><h2 id="gap-lock">GAP LOCK</h2></li>
<li><h2 id="next-key-lock">NEXT KEY LOCK</h2></li>
</ul></li>
<li><h1 id="mysql的日志">MySQL的日志</h1>
<ul>
<li><h2 id="wal-write-ahead-logging">WAL Write-Ahead Logging</h2>
<p>先写日志、再写入磁盘</p></li>
<li><h2 id="redo-log-重做日志">Redo Log 重做日志</h2>
<p>crash safe innoDB引擎层的日志 记录的是执行 SQL语句 的结果</p>
<ul>
<li><h3 id="两阶段提交">两阶段提交</h3></li>
</ul></li>
<li><h2 id="binlog-归档日志">BinLog 归档日志</h2>
<p>Server层的日志，无关引擎 记录的 SQL语句</p></li>
</ul></li>
</ul>
<!--
mysql config option file
官方文档：https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html

[client]
客户端配置，对应如 mysql -uroot，启动客户端 读取设定

[mysqld]
服务器配置，对应如 net start mysql，启动 mysql-server 读取设定

-->
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>索引</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>保留文件</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis-%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<!--
## 持久化  
&ensp;&ensp;Redis提供两种方法实现数据持久化。数据的持久化可以使数据重用，及系统故障后数据的恢复。  

### &ensp;&ensp;快照(snapshotting)  
&ensp;&ensp;快照会将某一时刻的所有数据保存到磁盘中。快照保存将数据保存到 **.rdb后缀** 的文件中。可以在配置文件中通过 **dbfilename** 设置保存的rdb文件名。创建快照的方法：  
#### &ensp;&ensp;&ensp;&ensp;BGSAVE命令  
&ensp;&ensp;&ensp;&ensp;在支持bgsave命令的平台(除了windows，一般都支持)中，会创建一个子进程，子进程负责把数据写入硬盘，父进程处理请求。  
#### &ensp;&ensp;&ensp;&ensp;SAVE命令  
&ensp;&ensp;&ensp;&ensp;save命令不创建子进程，在快照创建完成前不响应其他命令。
#### &ensp;&ensp;&ensp;&ensp;配置文件的save项  
&ensp;&ensp;&ensp;&ensp;通过配置文件中的save项，来自动开启bgsave命令。save 3600 1000，即1小时内有1000次写入，满足该条件，就会自动触发bgsave。可以配置多个save项。
#### &ensp;&ensp;&ensp;&ensp;接收关闭服务器命令  
&ensp;&ensp;&ensp;&ensp;当服务器接收到SHUTDOWN命令关闭之前，会执行save命令。  

&ensp;&ensp;快照持久化保存的是某一时刻的所有数据，如果在创建下一次RDB文件之前发生崩溃，则数据只能恢复到最后一次快照保存时的数据。  

### &ensp;&ensp;只追加文件(append-only-file)  
&ensp;&ensp;aof持久化会将执行的 **写** 命令添加到aof文件末尾。因此只要从头到尾执行一次aof文件中的指令，就可以恢复数据。通过配置文件中的 **appendsync** 项来改变写入文件的频率。appendsync有三种频率：    
#### &ensp;&ensp;&ensp;&ensp;&ensp;always  
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;每个写命令都要同步到硬盘中。
#### &ensp;&ensp;&ensp;&ensp;&ensp;everysec  
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;每秒执行一次同步
#### &ensp;&ensp;&ensp;&ensp;&ensp;no  
&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;由操作系统判断什么时候执行同步  

#### &ensp;&ensp;&ensp;&ensp;AOF文件重写/压缩  
&ensp;&ensp;&ensp;&ensp;当AOF文件占用空间越来越大时，可以通过BGREWRITEAOF命令重写AOF文件，去除冗余命令。BGREWRITEAOF命令会创建一个子进程来重写AOF，并删除旧AOF文件。  

### &ensp;&ensp;RDB和AOF优缺点  
#### &ensp;&ensp;&ensp;&ensp;RDB  
&ensp;&ensp;&ensp;&ensp;1.bgsave指令不影响其他命令执行。  
&ensp;&ensp;&ensp;&ensp;2.当数据量很大时，相对于AOF文件，RDB文件更小。  
&ensp;&ensp;&ensp;&ensp;3.保存的是一个时刻的全部数据，如果在下一次保存完成前崩溃，则会丢失这之间的数据。安全性不如AOF。  
&ensp;&ensp;&ensp;&ensp;4.bgsave指令使用到子进程，此时内存占用比较高。  

#### &ensp;&ensp;&ensp;&ensp;AOF  
&ensp;&ensp;&ensp;&ensp;1.AOF文件保存的是写命令，从到到尾执行一遍，数据就能恢复。因此安全性更高。  
&ensp;&ensp;&ensp;&ensp;2.可以通过redis-check-aof来修复AOF文件，防止写入AOF文件时服务器停机，导致的AOF文件出错。  
&ensp;&ensp;&ensp;&ensp;3.当数据量大时，AOF文件比RDB文件大，恢复速度也比RDB文件慢。  

&ensp;&ensp;当快照和AOF都存在时，数据恢复 **优先加载AOF** 文件。  

## 数据过期策略

#### &ensp;&ensp;定时删除
1

#### &ensp;&ensp;惰性删除
1

#### &ensp;&ensp;定期删除
1

#### &ensp;&ensp;RDB和AOF对过期key的处理

#### &ensp;&ensp;&ensp;&ensp;RDB的处理方法  
&ensp;&ensp;&ensp;&ensp;RDB不会保存过期的key  
#### &ensp;&ensp;&ensp;&ensp;AOF的处理方法  
&ensp;&ensp;&ensp;&ensp;当key过期时，会在文件中追加DEL命令，删除过期key。AOF文件重写时过期key，不会保存到AOF文件中。

## 数据淘汰策略
-->
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>RDB</tag>
        <tag>AOF</tag>
      </tags>
  </entry>
  <entry>
    <title>保留文件</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<!-- 
意图:
解决的问题:
-->
]]></content>
  </entry>
  <entry>
    <title>保留文件</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<!--
编码：
    将 信息 转换成 计算机 能够识别的 二进制序列。
    如 图片，文字，声音等都属于信息，需要转为二进制表示，该过程可以分类为：
        图形编码
        字符编码
        声音编码
        视频编码
计算机的关键点：
    1. 程序由 数据 和 指令 构成
    2. 计算机的关键步骤： 输入、计算、输出

IC：集成电路，每一个针脚对应的是 输入 或者 输出


-----------------------

HZ：显示器显示画面是 从左上到右下的 逐行扫描。  
    刷新率 就是指 1s中全屏幕完成逐行扫描的次数。60HZ ：1s 显示器能完成 60次 对全屏幕的逐行扫描。   
FPS：一个画面为 1帧，1s中的 画面个数。60FPS ： 1s 能生成 60帧。

分辨率：又称解析度、指系统对细节的分辨能力。可以细分为 图像分辨率、设备分辨率(打印机)。  
    在 1080P、4K分辨率屏幕上，打开同一个1080P分辨率的图片，4K屏幕上图片尺寸更小，而让图片尺寸。  
    在 1080P屏幕上，打开4K分辨率的图片，图片输出最终肯定还是1080P，但是 色度抽样为 4:4:4，色彩会更丰富。  
像素密度：单位长度内的像素数量除以单位长度，单位为PPI。5PPI ：每英寸有5个像素。  
像素总数：单独一帧图所含像素的数量。  
像素点： 每一个像素点 由 红 绿 蓝 三个子像素点 构成
色深： 每个 子像素点 亮度状态 bit数。6bit：就是指 每个子像素点 能够表示 2^6 个亮度状态 (000000 ~ 111111)。  
-->
]]></content>
  </entry>
  <entry>
    <title>保留文件</title>
    <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</url>
    <content><![CDATA[<!--
这种叫 有向无环图，把一个 有向无环图 转成 线性的排序 就叫 拓扑排序  

有向图有 入度 和 出度 的概念：
如果存在一条有向边 A -> B，则这条边给 A 增加了 1 个出度，给 B 增加了 1 个入度。

-->
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>保留文件</title>
    <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<!-- 
意图:
解决的问题:
-->
]]></content>
  </entry>
  <entry>
    <title>树结构</title>
    <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
    <content><![CDATA[<ul>
<li><h1 id="二叉树结构">二叉树结构</h1>
<ul>
<li><h2 id="二叉树的常见遍历方式">二叉树的常见遍历方式</h2>
<p>  前序遍历、中序遍历、后序遍历、Morris遍历、深度优先遍历、广度优先遍历。dfs一般涉及到递归和回溯。<br />
  二叉搜索树的中序遍历，就是节点值的从小到大的排列，也就是有序链表的从头到尾的顺序。</p></li>
<li><h2 id="二叉树的前中后序遍历">二叉树的前、中、后序遍历</h2>
<ul>
<li><h3 id="递归前中后序遍历">递归前、中、后序遍历</h3>
<p>  递归的方式遍历树没什么好说的，如果没有禁止递归的方式遍历，那么优先使用递归，更省事。N
个节点的二叉树，递归的时间复杂度为 O(N)，空间复杂度为
树的递归深度，也就是树的高度，平均为
O(logN)。最坏情况树成链状，空间复杂度为 O(N)。</p></li>
<li><h3 id="迭代前中后序遍历">迭代前、中、后序遍历</h3>
<p>  非递归方式的时间复杂度一样为节点个数 O(N)，空间复杂度为
栈的存储元素个数，同样和树的高度相关。平均为
O(logN)，最坏情况树成链状，空间复杂度为 O(N)。</p>
<ul>
<li><h4 id="前序遍历">前序遍历</h4>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        root <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  root以 先左后右 遍历树结构，栈用来保存途径节点。</p></li>
<li><h4 id="中序遍历">中序遍历</h4>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 相当于父节点入栈</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
      root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
      <span class="token comment">// 当 root节点为null，也就是 root的父节点 左子树为空</span>
      <span class="token class-name">TreeNode</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 遍历父节点的右子树</span>
      root <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  如上所示，前序遍历 和
中序遍历，只需要变更记录节点的位置即可。root以 先左后右
遍历树结构，栈用来保存途径节点。</p></li>
<li><h4 id="后序遍历">后序遍历</h4>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">TreeNode</span> curNode <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果当前节点没有 右节点，则直接读取该节点值</span>
        <span class="token comment">// 如果有 右节点，且已被读过。表示当前节点，左右都已遍历，则读取该节点值</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> curNode<span class="token punctuation">.</span>right <span class="token operator">==</span> preNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            preNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            root <span class="token operator">=</span> curNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  后续遍历总的思路不变，root以 先左后右
遍历树结构，栈用来保存途径节点，相当于保存父节点。使用preNode记录上一个读到的节点。<br />
  在后序遍历中，节点A的左节点，是A的左子树中，最后遍历的节点。A的右节点，是A的右子树中，最后遍历的节点。同时，A的右节点，是A左右子树中，最后一个遍历的节点。通过preNode保存最后访问的节点，来判断A的右子树是否遍历过。如果没有则遍历A的右子树,也就是root
= curNode.right，如果有则读取节点A的值。来实现后序遍历。</p></li>
</ul></li>
</ul></li>
<li><h2 id="二叉树morris遍历">二叉树Morris遍历</h2>
<ul>
<li><h3 id="换个角度看前序后序遍历">换个角度看前序、后序遍历</h3>
<p>  在二叉树的morris遍历之前，先了解下前序遍历和后序遍历。这样更方便理解Morris后序遍历。<br />
<img
src="/assets/posts_jpg/算法和数据结构/树结构/Morris_树的前序遍历是从上到下的顺序输出.jpg"
alt="树的前序遍历是从上到下的顺序输出" /><br />
  如上图所示，二叉树的前序遍历，也就是随着箭头数字的顺序，从上往下的顺序输出。</p>
<p><img
src="/assets/posts_jpg/算法和数据结构/树结构/Morris_树的后序遍历是从下往上的逆序输出.jpg"
alt="树的后序遍历是从下往上的逆序输出" /><br />
  如上图所示，二叉树的后序遍历，也就是随着箭头数字的顺序，从下往上的逆序输出。</p></li>
<li><h3 id="morris序">Morris序</h3>
<p>  Morris遍历，不通过辅助数组，而是使用叶子节点的空闲的指针。将叶子节点的右孩子指向后序节点，使得遍历能够从叶节点回到上面的某个节点。<br />
<img
src="/assets/posts_jpg/算法和数据结构/树结构/Morris_二叉树Morris遍历.jpg"
alt="二叉树Morris遍历" /><br />
  当前节点的 <strong>左子树</strong>
中，最右边的叶节点，就是当前节点的前序节点。找到该节点并将前序节点的右孩子指针，指向当前节点。这就是Morris遍历的一个重要的流程，而
Morris前序、中序、后序都是这个流程。Morris
遍历二叉树时，遍历的顺序都是一样的，和前序、后序这些无关。只是在不同的时机，来读取节点的值，来得到前、中、后序遍历结果。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Morris遍历的流程</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 当前节点没有左子树</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">TreeNode</span> preNode <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token comment">// 在当前节点的左子树中，找到最右的节点</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>preNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> preNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            preNode <span class="token operator">=</span> preNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 如果preNode.right不为空 表示当前节点之前遍历过</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>preNode<span class="token punctuation">.</span>right <span class="token operator">==</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token comment">// 重置指针</span>
            preNode<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            <span class="token comment">// 前序节点 指向 当前节点</span>
            preNode<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">;</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  上面的代码中，root变量表示
当前节点。那么图中的树在Morris遍历的流程中，root节点的访问顺序，也就是
<strong>Morris序</strong> 为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// * 表示第二次出现</span>
<span class="token number">1</span>、<span class="token number">2</span>、<span class="token number">4</span>、<span class="token number">8</span>、<span class="token operator">*</span><span class="token number">4</span>、<span class="token number">9</span>、<span class="token operator">*</span><span class="token number">2</span>、<span class="token number">5</span>、<span class="token number">10</span>、<span class="token operator">*</span><span class="token number">5</span>、<span class="token number">11</span>、<span class="token operator">*</span><span class="token number">1</span>、<span class="token number">3</span>、<span class="token number">6</span>、<span class="token operator">*</span><span class="token number">3</span>、<span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>  在Morris遍历中，左孩子不为空的节点，root会访问两次。<strong>第一次</strong>
遍历到时，将当前节点的左子树中最右节点，指向当前节点。<strong>第二次</strong>
遍历到时，需要重置前序节点的右孩子指针为null，防止破坏树的结构。因此，可以通过前序节点的
<strong>右孩子是否为null</strong> ，来判断 当前节点
是否是第一次访问。</p></li>
<li><h3 id="morris前中后序遍历">Morris前、中、后序遍历</h3>
<p>  在上面提到的 <strong>Morris序</strong>
中，如果出现两次的节点值中，取第一次，那么就是前序遍历，也就是第一次遍历到当前节点，取当前节点值。取第二次，就是中序遍历，也就是当前节点的左子树全部遍历完时，从前序节点回到当前节点时。如果当前节点没有左孩子，就是说
Morris序 中，只会出现一次的节点，那么直接取值即可。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 当前节点没有左子树</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 直接取值</span>
        ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">TreeNode</span> preNode <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token comment">// 在当前节点的左子树中，找到最右的节点</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>preNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> preNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            preNode <span class="token operator">=</span> preNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 如果preNode.right不为空 表示当前节点之前遍历过</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>preNode<span class="token punctuation">.</span>right <span class="token operator">==</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// ans.add(root.val); 这里读取，得到中序遍历结果</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token comment">// 重置指针</span>
            preNode<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            <span class="token comment">// ans.add(root.val); 这里读取，得到前序遍历结果</span>
            <span class="token comment">// 前序节点 指向 当前节点</span>
            preNode<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">;</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  从Morris遍历中得到后序遍历结果需要额外的处理，要结合上面提到的二叉树的后序遍历的逆序输出。因为后序遍历，就是从下向上的逆序遍历树。所以Morris后序遍历，在Morris序的基础上，需要这样实现：<br />
<img src="/assets/posts_jpg/算法和数据结构/树结构/Morris_后序遍历.jpg"
alt="Morris后序遍历" /><br />
  当前节点如果是第二次遍历到，那么 <strong>逆序</strong>
输出，当前节点的左孩子到前序节点之间的所有节点。根据图中树结构举例说明，当第二次遍历到4节点时，逆序输出8。当第二次遍历到2时，逆序输出9、4。当第二次遍历到5时，逆序输出10。当第二次遍历到1时，逆序输出11、5、2。当第二次遍历到3时，逆序输出6。根据这个例子可以看到，最后从
根节点 到
右子树最右叶子节点之间，没有办法在Morris序的流程中逆序输出，因此需要在Morris遍历流程结束后，再额外输出这部分节点。<br />
  而如何实现节点逆序输出，只看2、5、11这三个需要逆序输出的节点的话，其实就是一个
<strong>单向链</strong>
。因此反转2、5、11的单向链后，再输出，然后再反转一次复原即可。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">Morris</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">TreeNode</span> head <span class="token operator">=</span> root<span class="token punctuation">;</span>
    ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 没有左孩子</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            <span class="token comment">// 左子树最右叶节点</span>
            <span class="token class-name">TreeNode</span> preNode <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>preNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> preNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                preNode <span class="token operator">=</span> preNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>preNode<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                preNode<span class="token punctuation">.</span>right <span class="token operator">=</span> root<span class="token punctuation">;</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
                <span class="token comment">// 重置</span>
                preNode<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token comment">// 反转 左孩子 到 前序节点间的所有节点</span>
                <span class="token function">rev</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 复原并读取节点</span>
                <span class="token function">getAns</span><span class="token punctuation">(</span>preNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
                root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 将 根节点 到 最右节点反转</span>
    <span class="token class-name">TreeNode</span> rightNode <span class="token operator">=</span> <span class="token function">rev</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 复原</span>
    <span class="token function">getAns</span><span class="token punctuation">(</span>rightNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 反转</span>
<span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">rev</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">TreeNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">TreeNode</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        cur<span class="token punctuation">.</span>right <span class="token operator">=</span> pre<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
        cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> pre<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 遍历单向链并反转</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getAns</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> cur<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">TreeNode</span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">TreeNode</span> next <span class="token operator">=</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        cur<span class="token punctuation">.</span>right <span class="token operator">=</span> pre<span class="token punctuation">;</span>
        pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
        cur <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><h3 id="morris遍历时间复杂度">Morris遍历时间复杂度</h3>
<p>  Morris遍历中，除了 root 变量表示的遍历树时的当前节点，还有 preNode
节点，遍历树找到前序节点。而这个找到前序节点的流程有
<strong>两次</strong> 。第一次建立指针，第二次重置指针。每个 当前节点 到
前序节点的路径 是 <strong>不相交</strong>
的。如图中所示的，1节点的路径是2、5、11。2节点的路径是4、9。所有的当前节点到前序节点的路径，其实就相当于整个树。也就是说，Morris
遍历流程中，就算有 preNode
找前序节点，这过程也就相当于最多遍历两次树结构，时间复杂度为
O(N)。同理，Morris
后序遍历中，需要反转两次单向链，而所有的单向链，也就相当于整个树，最多遍历两次树结构。所以，Morris
遍历时间复杂度为 <strong>O(N)</strong> 。<br />
  Morris遍历没有使用辅助数组，因此空间复杂度是 O(1)。</p></li>
</ul></li>
<li><h2 id="二叉排序树-bst">二叉排序树 BST</h2>
<ul>
<li><h3 id="bst特点">BST特点</h3>
<ul>
<li>左子树的值都比 当前节点 小，右子树的值都比 当前节点 大。</li>
<li>当前节点的值，是左子树值的上限，是右子树值的下限。</li>
<li>中序遍历BST，结果递增。</li>
</ul></li>
<li><h3 id="验证bst">验证BST</h3>
<p>  根据BST的特点，可以中序遍历树，遍历结果如果不是递增的，则不是BST。也可以用递归验证
左子树 和 右子树
是否符合条件，也就是当前值不能小于下限，不能大于上限。</p></li>
<li><h3 id="bst节点更新">BST节点更新</h3>
<ul>
<li><h4 id="新增节点">新增节点</h4>
<p>  没什么好说的，比当前节点小的，放左子树中，比当前节点大的，放右子树中。</p></li>
<li><h4 id="删除节点">删除节点</h4>
<p>  将 当前节点，左子树中最大节点 或 右子树中最小节点，作为
替代节点，来取代当前节点，然后删除旧位置的替代节点。<br />
  AVL 和 红黑树 删除节点思路是基于 BST
删除节点衍生的。BST这里不写出大致流程，直接看后面的<a
href="#jump_avl_del"><font color="007FFF">AVL删除节点流程</font></a>。</p></li>
</ul></li>
<li><h3 id="bst缺点">BST缺点</h3>
<p>  BST结构实现了在查询时直接排除另一半子树上的节点，理想情况下时间复杂度为
O(logN)。但是最坏情况，当 树成链
结构时，BST查询只能每一个节点遍历，时间复杂度为 O(N)。<br />
  平衡二叉排序树 AVL，解决了这个缺点。</p></li>
</ul></li>
<li><h2 id="平衡二叉排序树-avl">平衡二叉排序树 AVL</h2>
<p>  AVL 在 BST 基础上新增特点：</p>
<ul>
<li>每个节点的 左子树 和 右子树 的深度之差，不超过 1。</li>
</ul>
<p>  将新增节点插入到 AVL 时，会发生节点 左右子树的深度差 超过
1，也就是平衡被破坏。 <img
src="/assets/posts_jpg/算法和数据结构/树结构/AVL_树的平衡破坏.jpg"
alt="AVL_树的平衡破坏" /><br />
  如上图所示，当插入新节点C时，平衡被破坏。新节点C是破坏平衡节点，A节点左右子树深度差大于
1，A节点是平衡被破坏节点。为了保持树的平衡，就需要将节点旋转来调整平衡，<strong>调整更长那一边</strong>
，旋转分为两种。</p>
<ul>
<li><h3 id="旋转">旋转 <span id="jump_avl_rotate"></span></h3>
<ul>
<li><h4 id="左旋">左旋</h4>
<p>  将 目标节点 转为 其右孩子 的 <strong>左</strong>孩子。</p></li>
<li><h4 id="右旋">右旋</h4>
<p>  将 目标节点 转为 其左孩子 的 <strong>右</strong>孩子。</p></li>
<li><h4 id="avl-参与旋转的节点">AVL 参与旋转的节点</h4>
<p>  当平衡被破坏时，旋转涉及到的主要节点为：被破坏节点 和 其子节点 和
其孙节点。会作为 目标节点 的，是 被破坏节点 和 其子节点。<br />
<img src="/assets/posts_jpg/算法和数据结构/树结构/AVL_参与旋转节点.jpg"
alt="AVL_参与旋转节点" /><br />
  如图所示，当新增 F 后，A 平衡被破坏。参与旋转的节点为：被破坏节点
A、子节点 B、孙节点 E。A节点 和 B节点 会作为旋转的 目标节点。</p></li>
</ul></li>
<li><h3 id="平衡被破坏时的-4-种调整">平衡被破坏时的 4 种调整</h3>
<p>  根据参与旋转的节点：被破坏节点，其子节点，其孙节点。3个节点的位置关系，可以分为四种调整方法：</p>
<ul>
<li><h4 id="ll右旋">LL，右旋</h4>
<p><img src="/assets/posts_jpg/算法和数据结构/树结构/AVL_LL右旋调整.jpg"
alt="LL右旋调整" /><br />
  破坏平衡节点 位于：被破坏节点 A 的 <strong>左孩子</strong> 的
<strong>左子树</strong> 中，也就是LL。进行右旋，将 A节点
转为右孩子。</p></li>
<li><h4 id="rr左旋">RR，左旋</h4>
<p><img src="/assets/posts_jpg/算法和数据结构/树结构/AVL_RR左旋调整.jpg"
alt="RR左旋调整" /><br />
  破坏平衡节点 位于：被破坏节点 A 的 <strong>右孩子</strong> 的
<strong>右子树</strong> 中，也就是RR。进行左旋，将 A节点
转为左孩子。</p></li>
<li><h4 id="lr先左再右">LR，先左再右</h4>
<p><img src="/assets/posts_jpg/算法和数据结构/树结构/AVL_LR先左再右.jpg"
alt="LR先左再右" /><br />
  破坏平衡节点 位于：被破坏节点 A 的 <strong>左孩子</strong> 的
<strong>右子树</strong> 中，也就是LR。先将 B节点 进行左旋，再对 A节点
进行右旋。</p></li>
<li><h4 id="rl先右再左">RL，先右再左</h4>
<p><img src="/assets/posts_jpg/算法和数据结构/树结构/AVL_RL先右再左.jpg"
alt="RL先右再左" /><br />
  破坏平衡节点 位于：被破坏节点 A 的 <strong>右孩子</strong> 的
<strong>左子树</strong> 中，也就是RL。先将 B节点 进行右旋，再对 A节点
进行左旋。</p></li>
</ul></li>
<li><h3 id="avl节点变化">AVL节点变化</h3>
<ul>
<li><h4 id="新增节点-1">新增节点</h4>
<p>  插入节点时，根据 AVL
特性，决定新节点的位置。需要注意的是，新增节点后，是对应的分支
<strong>深度+1</strong> 。如果平衡被破坏，那么肯定是 深度+1
这一边长度更长。通过 新节点 和 当前节点
的值大小，来判断出位置关系。<br />
  大致流程为：<br />
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> curNode<span class="token punctuation">,</span> <span class="token keyword">int</span> newVal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 新建节点</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>val <span class="token operator">></span> newVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 插入到 左边</span>
    curNode<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">insert</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">,</span> newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 平衡被破坏时</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">height</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">height</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// newVal 比 左孩子 小 --> LL</span>
      <span class="token comment">//                 大 --> LR</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>newVal <span class="token operator">&lt;</span> curNode<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">llMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        <span class="token function">lrMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> newVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 插入到 右边，思路同左边，省略</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> curNode<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></li>
<li><h4 id="删除节点-1">删除节点 <span id="jump_avl_del"></span></h4>
<p>  删除节点时，根据 AVL
特性，可以判断要删除的节点方向。需要注意的是，删除节点后，是对应的分支
<strong>深度-1</strong> 。如果平衡被破坏，那么肯定是 深度不变
这一方更长。所以需要 <strong>判断子节点深度</strong>
来辨别位置关系。<br />
  大致流程为：<br />
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">TreeNode</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> curNode<span class="token punctuation">,</span> <span class="token keyword">int</span> delVal<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>val <span class="token operator">></span> delVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 要删除的 在左边</span>
    curNode<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">,</span> delVal<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 平衡被破坏</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token function">height</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">height</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 判断 右孩子 的 左子树 和 右子树 深度 </span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">height</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>right<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token function">height</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">rrMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        <span class="token function">rlMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> delVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 要删除的 在右边，思路同左边，省略</span>
  <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// curNode 就是 要删除的节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> curNode<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token comment">// 比较深度</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">height</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token function">height</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 左子树更深，将左子树中 最大的节点 移到 curNode位置，赋值就行</span>
        <span class="token keyword">int</span> leftMaxVal <span class="token operator">=</span> <span class="token function">getMax</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        curNode<span class="token punctuation">.</span>val <span class="token operator">=</span> leftMaxVal<span class="token punctuation">;</span>
        <span class="token comment">// 删除 原来的位置</span>
        <span class="token function">delete</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">,</span> leftMaxVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        <span class="token comment">// 同理，右子树中 最小的节点，省略</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
      curNode <span class="token operator">=</span> curNode<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> curNode<span class="token punctuation">.</span>right <span class="token operator">:</span> curNode<span class="token punctuation">.</span>left<span class="token operator">:</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
  <span class="token keyword">return</span> curNode<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>   在上面删除节点的大致流程中，当 curNode
就是要删除的节点，且 curNode 左右子树 <strong>都不为空</strong>
，那么将更长那一方的子树，左子树最大节点 或 右子树最小节点，移到 curNode
位置，变相的删除 curNode。此时就从删除
curNode，递归成了删除子树中的旧节点。<br />
<img src="/assets/posts_jpg/算法和数据结构/树结构/AVL_删除节点.jpg"
alt="AVL删除节点" /><br />
  当 E节点 为要删除的节点时，通过将左子树中最大 F节点 移到 E节点
位置，来删除 E节点。此时流程就递归成了，在左子树中删除
旧F节点。</p></li>
</ul></li>
<li><h3 id="avl缺点">AVL缺点</h3>
<p>  当更新节点时，为了保证深度差的平衡结构，需要旋转更新树结构。当数据新增或者删除等操作频繁时，对应的调整树结构的旋转也会消耗更多的资源。<br />
  红黑树 不需要像 AVL 一样频繁的调整平衡。</p></li>
</ul></li>
<li><h2 id="红黑树">红黑树 <span id="jump_rbt"></span></h2>
<ul>
<li><h3 id="红黑树在-avl-上新增特点">红黑树在 AVL 上新增特点</h3>
<ul>
<li><strong>a</strong> 不必须保持，左右子树深度差的平衡 。</li>
<li>b 节点逻辑上分为 红 和 黑 两种节点。</li>
<li><strong>c</strong> 任意节点 到 其可达叶节点 的路径，上面的 黑节点
数量一致。</li>
<li><strong>d</strong> 所有路径上不会有连续的 红节点，红节点 父、子节点
一定是 黑节点。</li>
<li>e 根节点 一定是 黑节点，Null 视为 黑节点。新插入的节点视为 红节点
插入。</li>
</ul>
<p>  在上面的几个特点中，需要注意的是：当插入新节点时，可能会破坏规则
d，红节点破坏平衡；当删除节点时，可能会破坏规则
c，黑节点破坏平衡。</p></li>
<li><h3 id="红黑树新增节点-红节点破坏平衡">红黑树新增节点
(红节点破坏平衡)</h3>
<p><img src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_1.jpg"
alt="红黑树_1" /><br />
  在插入新节点时，因为新节点视为红色插入，所以会引起红黑平衡破坏的场景为：连续的红节点，新节点的父节点为红节点。同时能够得到：如果父节点是
黑节点，就能直接插入新节点。父节点为红时，分为两种情况：</p>
<ul>
<li><h4 id="叔为红">叔为红</h4>
<p><img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_平衡破坏_红节点.jpg"
alt="红黑树_红黑平衡破坏" /><br />
  当父、叔节点都为红节点时，将父、叔节点 和 爷节点 颜色对调。爷节点 变为
红节点，父、叔节点 变为 黑节点。如果 爷节点 是
<strong>根节点</strong>，再将 红色 改为
黑色。因为爷节点改成了红色，可能会成为了破坏上层红黑平衡的节点，就需要<strong>继续向上调整</strong>。</p></li>
<li><h4 id="叔为黑">叔为黑</h4>
<p>  当叔节点为黑时，与 AVL
的参与旋转的节点位置关系思路一致，根据位置来进行 <a
href="#jump_avl_rotate"><font color="#007FFF">旋转</font></a> 和
变色。<br />
  红黑树中参与旋转的节点有：破坏红黑平衡节点，其父节点，其爷节点。<br />
<img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_参与旋转节点.jpg"
alt="红黑树_参与旋转节点" /><br />
  如上图所示，新节点E
破坏了红黑平衡，其父节点D、爷节点B，3个节点参与红黑调整。旋转思路和 AVL
一样。变色思路就是 爷节点 和 其子节点 颜色对调。</p>
<ul>
<li><h5 id="rl-和-rr">RL 和 RR</h5>
<p><img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_RL_RR旋转.jpg"
alt="红黑树_RL_RR旋转" /><br />
  旋转的思路和 AVL 一致。当 RL 旋转成 RR 时，将 爷节点 和 其子节点
颜色对调，再继续旋转。</p></li>
<li><h5 id="lr-和-ll">LR 和 LL</h5>
<p><img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_LR_LL旋转.jpg"
alt="红黑树_LR_LL旋转" /><br />
  旋转的思路和 AVL 一致。当 LR 旋转成 LL 时，将 爷节点 和 其子节点
颜色对调，再继续旋转。</p></li>
</ul>
<p>  总结：当参与调整的三个节点，在一条直线上时，对调颜色。节点旋转思路和
AVL 一致。</p></li>
</ul>
<p>  红黑树的节点一般会有 parent 字段记录父节点。红黑平衡涉及到
爷节点、叔节点等。<br />
  用变量记录 爷节点、叔节点 等，就能辨别颜色场景。只要注意 根节点
一定要为
黑色，且在参与旋转的节点在一条直线时，颜色对调即可。剩下的思路和 AVL
一致。</p></li>
<li><h3 id="红黑树删除节点">红黑树删除节点</h3>
<p>  在删除节点时，会引起红黑平衡被破坏的场景：路径上黑节点数量不一致，也就是删除了黑色节点。<br />
  红黑树删除节点思路和<a
href="#jump_avl_del"><font color="007FFF">AVL删除节点</font></a>类似。在红黑树中删除一个节点，有以下场景：</p>
<ul>
<li><h4 id="场景a删除红色叶子节点">场景A：删除红色叶子节点 <span
id="jump_rbt_del_a"></span></h4>
<p>  不会破坏红黑平衡，直接删除。<br />
<img src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_删除节点_A.jpg"
alt="红黑树_删除节点_A" /><br />
  没什么好说。</p></li>
<li><h4 id="场景b删除黑色叶子节点">场景B：删除黑色叶子节点 <span
id="jump_rbt_del_b"></span></h4>
<p>  会破坏红黑平衡，需要调整。删除黑色叶节点情况复杂，单独拿出来举例：<a
href="#jump_rbt_del_b0"><font color="007FFF">黑节点破坏红黑平衡</font></a>。</p></li>
<li><h4 id="场景c删除节点只有一个子节点">场景C：删除节点只有一个子节点
<span id="jump_rbt_del_c"></span></h4>
<ul>
<li><p>C1.
删除节点为红，不可能只有一个子节点，因此不会出现这种场景。</p></li>
<li><p>C2. 删除节点为黑，唯一子节点只可能为 <strong>红节点</strong> 且
<strong>一定是叶节点</strong>。将替代节点取代删除节点，并将颜色置为删除节点同色。删除旧位置替代节点等价于<a
href="#jump_rbt_del_a"><font color="007FFF">场景A</font></a>。<br />
<img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_删除节点_C2.jpg"
alt="红黑树_删除节点_C2" /></p></li>
</ul></li>
<li><h4 id="场景d删除节点有两个子节点">场景D：删除节点有两个子节点</h4>
<p>  替代节点 取代 删除节点后，再删除原替代节点。</p>
<ul>
<li><p>D1. 替代节点 没有子节点
且为红色，将替换节点取代并和删除节点同色。后续删除等价于<a
href="#jump_rbt_del_a"><font color="007FFF">场景A</font></a>。<br />
<img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_删除节点_D1.jpg"
alt="红黑树_删除节点_D1" /></p></li>
<li><p>D2. 替代节点 没有子节点 且为黑色，等价于<a
href="#jump_rbt_del_b"><font color="007FFF">场景B</font></a>。</p></li>
<li><p>D3. 替代节点
有一个子节点，将替换节点取代并和删除节点同色。后续删除等价于<a
href="#jump_rbt_del_c"><font color="007FFF">场景C</font></a>。<br />
<img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_删除节点_D3.jpg"
alt="红黑树_删除节点_D3" /></p></li>
</ul></li>
</ul></li>
<li><h3 id="黑节点破坏平衡">黑节点破坏平衡 <span
id="jump_rbt_del_b0"></span></h3>
<p><img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_平衡破坏_黑节点.jpg"
alt="红黑树_平衡破坏_黑节点" />
  删除黑节点后，会导致某个节点其路径的黑节点数量不一致。如图所示：当
A节点 处于平衡被破坏状态。但是 B节点 平衡正常，所以主动将 B节点
的红孩子置为黑色，使得 B节点
也处于平衡被破坏状态。大致思路：删除黑色叶子节点后，会导致父节点失衡，此时主动破坏兄弟节点的平衡，再通过位置关系进行旋转处理。<br />
  删除黑色<strong>叶</strong>节点分为以下场景：</p>
<ul>
<li><h4 id="b1.兄弟为红">B1.兄弟为红 <span
id="jump_rbt_del_b1"></span></h4>
<p>  当前节点是黑色叶节点，兄弟节点为红。那么根据红黑平衡规则可得：父节点一定为黑色，且兄弟节点一定有两个黑色子节点。<br />
<img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_删除节点_B_兄红.jpg"
alt="红黑树_删除节点_B_兄红" /><br />
  删除 B节点 后，A节点 失衡，将 C节点 和 D节点 颜色对换，能够得到
A、C节点 RR失衡，左旋处理。</p></li>
<li><h4 id="b2.兄弟为黑_两个子节点">B2.兄弟为黑_两个子节点 <span
id="jump_rbt_del_b2"></span></h4>
<p>  父节点颜色不影响平衡调整。当前节点是黑色叶节点，兄弟节点为黑，且有两个子节点。那么根据红黑平衡规则可得：<strong>两个子节点一定为红</strong>
。所以 B2 场景也是指，两个红子节点。<br />
<img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_删除节点_B_兄黑_两子.jpg"
alt="红黑树_删除节点_B_兄黑_两子" /><br />
  删除 B节点 后，A节点 失衡，将 E节点 置为黑色，能够得到 A、C节点
RR失衡，左旋处理。</p>
<ul>
<li>A节点 是黑色，直接左旋就可以。</li>
<li>A节点 是红色，为了保持平衡，需要将 A、C 颜色对换，再左旋。</li>
</ul>
<p>  综合以上得到：先将 兄弟 和 父节点 颜色对换，再左旋。</p></li>
<li><h4 id="b3.兄弟为黑_一个子节点">B3.兄弟为黑_一个子节点 <span
id="jump_rbt_del_b3"></span></h4>
<p>  父节点颜色不影响平衡调整。当前节点是黑色叶节点，兄弟节点为黑，且只有一个子节点。那么根据红黑平衡规则可得：<strong>子节点一定为红</strong>
。所以 B3 场景也是指，一个红子节点。<br />
<img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_删除节点_B_兄黑_一子.jpg"
alt="红黑树_删除节点_B_兄黑_一子" /><br />
  主动破坏 C节点 的平衡，可以得到 RL 或 RR 失衡，而 RL失衡，又能转为
RR失衡。和 B2场景 类似，为了保持平衡，先将 兄弟 和 父节点
颜色对换，再左旋。</p></li>
<li><h4 id="b4.兄弟为黑_无子节点_父为红">B4.兄弟为黑_无子节点_父为红
<span id="jump_rbt_del_b4"></span></h4>
<p>  当前节点是黑色叶节点，兄弟节点为黑，且没有子节点。根据规则：Null
视为 黑色。所以 B4 场景也是指，无红子节点。<br />
<img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_删除节点_B_兄黑_无子_父红.jpg"
alt="红黑树_删除节点_B_兄黑_无子_父红" /></p></li>
<li><h4 id="b5.兄弟为黑_无子节点_父为黑">B5.兄弟为黑_无子节点_父为黑
<span id="jump_rbt_del_b5"></span></h4>
<p>  当前节点是黑色叶节点，兄弟节点为黑，且没有子节点。根据规则：Null
视为 黑色。所以 B5 场景也是指，无红子节点。<br />
<img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_删除节点_B_兄黑_无子_父黑.jpg"
alt="红黑树_删除节点_B_兄黑_无子_父黑" /><br />
  A节点
平衡后，改变了黑节点深度，会导致上层节点的红黑平衡被破坏，所以需要往上层节点继续调整平衡。直到
根节点 或者 遇到 <em>B1 ~ B4</em>
调整后不会改变黑节点深度的场景。</p></li>
<li><h4 id="删除流程整合">删除流程整合</h4>
<p>  <em>B1 ~ B4</em> 的场景，调整前黑节点深度 等于
调整后黑节点深度，也就是该子树部分 <strong>黑节点深度不变</strong>
。子树的黑节点深度不变表示：不需要往上处理其他节点 。<br />
  <em>B5</em> 的场景导致黑节点深度变化。要向上处理，可能会遇到 <em>B1 ~
B5</em> 全部场景，处理方式不变。只是 <em>B1 ~ B5</em>
是黑色<strong>叶</strong>子节点的条件，所以向上调整时，当前节点和其他节点的关系条件稍作修改。修改方式就是根据红黑树规则，将
Null 视为黑色，那么 <em>B3</em> 场景相当于一红一黑的条件，<em>B5</em>
场景相当于两个黑子节点。同理转换可得：</p>
<ul>
<li>兄弟为红 ---&gt; <a
href="#jump_rbt_del_b1"><font color="007FFF">B1</font></a> 。</li>
<li>兄弟为黑_<strong>两个红色</strong>子节点 ---&gt; <a
href="#jump_rbt_del_b2"><font color="007FFF">B2</font></a> 。</li>
<li>兄弟为黑_<strong>一个红色</strong>子节点 ---&gt; <a
href="#jump_rbt_del_b3"><font color="007FFF">B3</font></a> 。</li>
<li>兄弟为黑_<strong>无红色</strong>子节点_父为红 ---&gt; <a
href="#jump_rbt_del_b4"><font color="007FFF">B4</font></a> 。</li>
<li>兄弟为黑_<strong>无红色</strong>子节点_父为黑 ---&gt; <a
href="#jump_rbt_del_b5"><font color="007FFF">B5</font></a> 。</li>
</ul>
<p>  如果再遇到 <em>B5</em> 场景，就继续向上调整，直到当前节点为 根节点
或者 遇到 <em>B1 ~ B4</em> 场景。<br />
<img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_删除节点_B_流程整合_1.jpg"
alt="红黑树_删除节点_B_流程整合_1" /><br />
  如上图所示，删除节点D，处于 <em>B5</em>
场景。调整后黑节点深度变化，继续向上平衡。此时处于 场景 <em>B5</em>
，调整后黑节点深度变化，继续向上平衡。此时当前节点为
根节点，结束。<br />
<img
src="/assets/posts_jpg/算法和数据结构/树结构/红黑树_删除节点_B_流程整合_2.jpg"
alt="红黑树_删除节点_B_流程整合_2" /><br />
  如上图所示，删除节点G，处于 <em>B5</em>
场景。调整后黑节点深度变化，继续向上平衡。此时处于 场景 <em>B3</em>
，调整后黑节点深度不变，结束。</p></li>
</ul>
<p>  上面所有的场景，基本都是删除节点为左孩子的场景，右孩子的场景思路相同，省略。</p></li>
<li><h3 id="avl树-和-红黑树比较">AVL树 和 红黑树比较</h3>
<ul>
<li>N个节点的红黑树，其深度最大值 <span class="math inline">\(2*log(N +
1)\)</span></li>
<li>N个节点的AVL，深度为 <span class="math inline">\(logN +
1\)</span>。</li>
<li>红黑树不需要频繁调整树结构，综合性能更强。</li>
<li>AVL树，平衡结构更好，查询效率更好。</li>
<li>当场景写操作少，读操作多，可以用 AVL。其他场景 红黑树更好。</li>
</ul></li>
</ul></li>
</ul></li>
<li><h1 id="多叉树结构">多叉树结构</h1>
<ul>
<li><h2 id="b树">B树</h2></li>
<li><h2 id="b树-1">B+树</h2></li>
<li><h2 id="字典树前缀树-trie">字典树/前缀树 Trie</h2>
<ul>
<li><h3 id="前缀和">前缀和</h3>
  当题目要求，计算 数组的子区间，单向链或树中的单向链路径 的
总和，类似这种的 连续子区间。大概率可以通过 前缀和
解决。前缀和的大致思路：对于 preI 为 0 ~ i 的 前缀和，preJ 为 0 ~ j
的前缀和，且 j &gt; i。那么 preJ - preI 就是 区间 i+1 ~ j 的 总和。</li>
</ul></li>
</ul></li>
<li><h1 id="树结构与算法">树结构与算法</h1>
<ul>
<li><h2 id="广度优先遍历">广度优先遍历</h2>
  当需要计算 树或图 节点与节点
间的最短路径，一般都是指使用bfs。同时可以通过 起点和终点
两边bfs来优化，减少搜索空间。类似与题126，就抓该题的关键字，图的最短路径-&gt;bfs，全部结果-&gt;dfs，除了关键字以外，该题还涉及到
建图。</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>链结构</title>
    <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE/</url>
    <content><![CDATA[<!-- 
### 单向链常见处理方式  
&ensp;&ensp;1.反转链：头插法，迭代法。
&ensp;&ensp;2.快慢指针找中间节点；  
&ensp;&ensp;3.逆序遍历单向链：反转链或者递归；  
&ensp;&ensp;4.逆序遍历单向链部分节点：反转部分链；  
&ensp;&ensp;5.拆分单向链：将单向链中某个节点，next 指针置为 null，就相当于拆分了链。置为null前先记录 next所指节点，就相当于有了head1 和 head2 两个链。  

### Floyd判圈算法(龟兔赛跑算法)  

#### &ensp;&ensp;证明：快慢指针 在慢指针第一圈 前相遇  

#### &ensp;&ensp;证明：快慢指针 第二次相遇 在环入口   

# 跳表 SkipList
-->
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记_LC原题</title>
    <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%94%E8%AE%B0-LC%E5%8E%9F%E9%A2%98/</url>
    <content><![CDATA[<ul>
<li><h1 id="寻找两个正序数组的中位数">04_寻找两个正序数组的中位数</h1>
<ul>
<li><h2 id="找第k个数">找第K个数</h2>
<p>  实现方法1，在两个有序数组中，找第K个数，只是K在该场景下等于
长度/2，也就是中位数是特殊的第K个数。每次循环 比较两数组 第K/2
上的数，并排除K/2个。当K为1时，两数组中，小的那个就是第K个数。该方法时间复杂度
O(logK)。但是没有用到中位数的特性，只是把中位数当 第K个处理。</p></li>
<li><h2 id="数组区域划分">数组区域划分</h2>
<p>  实现方法2，在两个数组1和2中找中位数，将两个数组分别划分为左右两个区域。左区域个数根据len1和len2计算出。假设
i为数组1上划分左右的坐标，j为数组2上划分左右的坐标。得i + j =
左区域个数。然后再根据，中位数特性2，找到符合条件的位置，就能找到中位数。时间复杂度
O(log(min(len1,len2)))<br />
<img
src="/assets/posts_jpg/算法和数据结构/Leetcode原题/Leetcode_04_寻找两个正序数组的中位数.jpg"
alt="leetcode_04" /></p></li>
</ul></li>
<li><h1 id="接雨水">42_接雨水</h1>
<p>  接雨水题，如果是计算i位置垂直容量，那么涉及
min(i左边最大高度，i右边最大高度)，因此需要双指针，或者2个辅助数组保存i位置的左右最大高度。如果计算i
和 j之间的水平容量，使用单调递减栈计算。<br />
<img
src="/assets/posts_jpg/算法和数据结构/Leetcode原题/Leetcode_42_接雨水_思路.jpg"
alt="接雨水双指针思路" /><br />
  如图所示，假设右边存在一个比左边都高的高度，可以使得左区域的位置i，垂直容量只需要考虑i位置时的leftMax。因此一个变量来保存并更新leftMax即可。同理，如果左边存在一个比右边都高的高度，右区域只需要考虑rightMax。<br />
<img
src="/assets/posts_jpg/算法和数据结构/Leetcode原题/Leetcode_42_接雨水.jpg"
alt="接雨水双指针" /><br />
  如图所示，当存在 left高度 小于
right高度时，那么right位置，就相当于上面提到的，比左区域都大的高度。那么left位置能存储的雨水，只需要考虑，
0 ~ left位置的 leftMax。同理，如果存在 left高度 大于
right高度时，right位置能存储的雨水，只需考虑，right ~ length - 1位置的
rightMax。</p></li>
<li><h1 id="不同路径">62_不同路径</h1>
<p>  该题动态规划的解法没什么要说的，记录一下 排列组合方式
的思路及为什么可以这样解。<br />
  假设在m * n 的矩阵中，高度为 m，长度为 n。因此从 0,0 位置 移动到
m-1,n-1 位置，需要 下移 m-1 次，右移 n-1 次。总共 m + n - 2
次。也就是说路径固定有 m + n - 2 个操作。<br />
<img
src="/assets/posts_jpg/算法和数据结构/Leetcode原题/Leetcode_62_不同路径.jpg"
alt="62_排列组合解法思路" /><br />
  如上图所示，每一个方格相当于 从 0,0 到 m-1,n-1 的一步操作，总共 m + n
- 2 个，而方格的从左到右，相当于操作顺序。也就是说，在 m + n - 2
个操作中， 选出 m - 1 个作为下移，或者 选出 n -
1个作为右移即可。方格本身的位置已经代表着执行的顺序，因此选出 m - 1
个作为下移 的排列组合结果，就相当于矩阵中的所有不同路径。因此直接计算
<span class="math inline">\(C{^{m-1}_{m+n-2}}\)</span> 或者 <span
class="math inline">\(C{^{n-1}_{m+n-2}}\)</span> 即可。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* 每连续2个整数一定有 2 的倍数
每连续3个整数一定有 3 的倍数，以此类推
因此下面这个，计算排列组合的结果一定是整数 */</span>
<span class="token keyword">long</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> n<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> y <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">,</span> <span class="token operator">++</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ans <span class="token operator">=</span> ans <span class="token operator">*</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><h1 id="x的平方根">69_x的平方根</h1>
<ul>
<li><h2 id="二分查找法">二分查找法</h2>
<p>  以二分查找的思路，start 为 1，end 为 x，计算mid * mid 和
x的关系。这种方法没什么好说的。只是需要注意 mid * mid
可能会超过整型最大值，因此可以比较 mid 和 x/mid。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token comment">// 防止 mid * mid 溢出</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">&lt;=</span> x <span class="token operator">/</span> mid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      ans <span class="token operator">=</span> mid<span class="token punctuation">;</span>
      start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
      end <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><h2 id="牛顿迭代法">牛顿迭代法</h2>
<p><img src="/assets/posts_jpg/算法和数据结构/算法/牛顿迭代法.jpg"
alt="Leetcode_69_x的平方根_牛顿迭代法" /><br />
  如图所示，计算C的平方根，可以理解成 <span class="math inline">\(x^2 =
C\)</span> 。也就是 <span class="math inline">\(y = x^2 - C\)</span>
，当 y = 0时，x 的值，也就是曲线和 x轴
的交点。而牛顿迭代法就是从初始值<span
class="math inline">\(x_0\)</span>，一直向交点接近。<br />
  <span
class="math inline">\(x_0\)</span>一般取C值即可，防止过大，或者过小。<span
class="math inline">\(x_0\)</span>和曲线的交点为 <span
class="math inline">\(x_0\)</span> , <span
class="math inline">\(x{_0}{^2} - C\)</span> 。该点的切线曲率为 <span
class="math inline">\(2x_0\)</span>，因此该切线的方程式为：<span
class="math inline">\(y = 2x_0 * (x - x_0) + x{_0}{^2} -
C\)</span>，因此 <span class="math inline">\(x_1\)</span> 就是当 y =
0时的值。也就是 <span class="math inline">\(x_1 = (x_0 + C/x_0) /
2\)</span> 。也就是说，代码这样写即可:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">xi <span class="token operator">=</span> <span class="token punctuation">(</span>x0 <span class="token operator">+</span> <span class="token class-name">C</span><span class="token operator">/</span>x0<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
x0 <span class="token operator">=</span> xi<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>  当两次结果，也就是上一次结果x0，和这一次结果xi，非常接近时，就可以视为结束。也就是:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">xi <span class="token operator">=</span> <span class="token punctuation">(</span>x0 <span class="token operator">+</span> <span class="token class-name">C</span><span class="token operator">/</span>x0<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>x0 <span class="token operator">-</span> xi<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0.0000001</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
x0 <span class="token operator">=</span> xi<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul></li>
<li><h1 id="不同的二叉搜索树">95_96_不同的二叉搜索树</h1>
<ul>
<li><h2 id="不同的二叉搜索树的数量">不同的二叉搜索树的数量</h2>
<p>  这一题动态规划的方程式，及二叉搜索树的理解很重要。设f(n)为n个节点时的集合数量。假设n为3。那么该树节点值就是
1~3。n为3时的二叉搜索树集合，就是 1为头节点集合 + 2为头节点集合 +
3为头节点集合。1为头节点，右边有2个节点，这两个节点的集合数量就相当于
f(2)，同理，左边0个节点，集合数量就为
f(0)。1为头节点的集合数量，就相当于 f(0) * f(2)。同理可得
2为头节点时的集合数量为 f(1) * f(1)。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">状态转换方程式为 <span class="token operator">:</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 根据动态规划方程式计算 res[i] 的结果</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> res<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> res<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><h2 id="生成不同的二叉搜索树集合">生成不同的二叉搜索树集合</h2>
<p>  这一题的递归解法，比较符合宏观的角度写出流程，然后再考虑出口，记录一下。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 生成 节点为 start ~ end 的 二叉搜索树 集合</span>
<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">></span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 以 i 为root节点的树</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// root节点为 i 时，左子树有 i - 1个节点</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> leftTree <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// root节点为 i 时，右子树有 end - i个节点</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TreeNode</span><span class="token punctuation">></span></span> rightTree <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 拼接树</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span> left <span class="token operator">:</span> leftTree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span> right <span class="token operator">:</span> rightTree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// 当前root节点 是 i</span>
                <span class="token class-name">TreeNode</span> curRoot <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                curRoot<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>
                curRoot<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>
                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul></li>
<li><h1 id="只出现一次的数字">137_只出现一次的数字</h1></li>
<li><h1
id="环形链表衍生_287_寻找重复数">142_环形链表衍生_287_寻找重复数</h1></li>
<li><h1 id="直线上最多的点数">149_直线上最多的点数</h1>
<ul>
<li><h2
id="证明最多只有1条直线上的节点数-大于-总结点数一半">证明：最多只有1条直线上的节点数
大于 总结点数一半</h2>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>ans <span class="token operator">>=</span> points<span class="token punctuation">.</span>length <span class="token operator">-</span> i <span class="token operator">||</span> ans <span class="token operator">></span> points<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul></li>
<li><h1 id="最短无序连续子数组">581_最短无序连续子数组</h1>
<p>最短无序连续子数组</p></li>
<li><h1 id="和为-k-的子数组">560_和为 K 的子数组</h1>
<p>和为 K 的子数组</p></li>
<li><h1 id="任务调度器">621_任务调度器</h1></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法笔记_数据结构与算法</title>
    <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li><h1 id="数据结构">数据结构</h1>
<ul>
<li><h2 id="堆">堆</h2>
<ul>
<li><h3 id="建堆的时间复杂度">建堆的时间复杂度</h3>
<p>  建堆时，当前节点向上移动，也就是说父节点向下移动。对于长度为N的数组，高度为H；H
= log2(N) + 1：<br />
  原最后一层的节点 下移的次数 为0，原倒数第二层
最多下移一次，以此类推。<br />
  假设当前高度为X，该层共有 2^(X - 1) 个节点。倒数第一层所有节点时间 +
倒数第二层所有节点时间 + .... + 第一层时间所有节点时间2^(H - 1) * 0 +
2^(H - 2) * 1 + ... + 2^(0) * (H - 1) = 2N - 2 - log2(N) = O(N);因此
时间复杂度为 O(N)</p></li>
<li><h3 id="数组-和-i---12迭代">数组 和 (i - 1)/2迭代</h3>
<p>  当遇到数组，和坐标i的公式迭代：(i - 1) &gt;&gt; 1 或 (i - 1)/2
这类时，一般就是和 堆 相关的，i是当前新插入的元素，(i -
1)/2是父节点的坐标。</p></li>
</ul></li>
<li><h2 id="单调栈">单调栈</h2>
<p>  在一维数组中对每一个数找到第一个比自己 小/大 的元素。这类
“在一维数组中找第一个满足某种条件的数”
的场景就是典型的单调栈应用场景<br />
  数组中，对每一个数，从左往右，或从右往左，找到第一个满足某条件的数，这种场景下，一般就是使用单调栈<br />
  需要找到当前位置，左边或者右边，第一个满足某条件的 (大或者小)</p></li>
<li><h2 id="并查集">并查集</h2></li>
<li><h2 id="字典树">字典树</h2></li>
</ul></li>
<li><h1 id="算法">算法</h1>
<ul>
<li><h2 id="排序算法">排序算法</h2>
<ul>
<li><h3 id="归并排序自顶向下">归并排序，自顶向下</h3>
<p>  也就是通过递归实现。具体没什么好说的。因为是通过递归实现，因此除了创建数组的空间复杂度外，需要消耗
方法入栈 的空间复杂度。也就是O(logN)，为递归的深度。</p></li>
<li><h3 id="归并排序自底向上">归并排序，自底向上</h3>
<p>  不使用递归的方法，不需要消耗递归的O(logN)的空间复杂度。思路有些类似于
希尔排序的步长，先从底层，每两个排序，再到每四个排序，以此类推。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> length <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token comment">// i表示 合并的个数</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> length<span class="token punctuation">;</span> i <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> leftStart <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> leftStart <span class="token operator">+</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>leftStart <span class="token operator">&lt;</span> length <span class="token operator">&amp;&amp;</span> mid <span class="token operator">&lt;</span> length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> rightEnd <span class="token operator">=</span> mid <span class="token operator">+</span> i <span class="token operator">>=</span> length <span class="token operator">?</span>  length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">:</span> mid <span class="token operator">+</span> i<span class="token punctuation">;</span>
        <span class="token comment">// 合并 leftStart ~ mid 和 mid + 1 ~ rightEnd </span>
        <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> leftStart<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> rightEnd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        leftStart <span class="token operator">=</span> rightEnd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        mid <span class="token operator">=</span> leftStart <span class="token operator">+</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  自底向上的方法中，需要注意的是数组的长度。假设数组长度为10，递归方法的流程大致为：10
分成 5 和 5的长度，5 分成 2 和
3的长度。也就是说，递归方法不需要注意数组划分后的长度。不管数组的长度是多少，都能直接分成2个部分。<br />
  而自底向上的流程大致为：i为 1 时，坐标 0、1
排序，2、3排序......8、9排序。i为 2 时，坐标
0、1、2、3排序，4、5、6、7排序，i为 4 时，坐标 0 ~ 7 排序。因为 i
是从1开始翻倍，如果当 数组长度为 10，i为 8，那么最后合并的子数组长度为
8、2。</p></li>
</ul></li>
<li><h2 id="位运算相关算法">位运算相关算法</h2>
<ul>
<li><h3 id="k-k-1">k &amp; (k-1)</h3>
<p>  Brian Kernighan算法，k &amp; (k - 1) 得到的值，就相当于在 k
中，从低位到高位，移除第一个 1，也就是最右侧的 1，其他位不变。</p></li>
<li><h3 id="k--k">k &amp; -k</h3>
<p>  k &amp; -k 得到的结果，就相当于在 k 中，从高位到低位，移除第一个
1，也就是移除最左侧的 1，其他位不变。</p></li>
</ul></li>
<li><h2 id="牛顿迭代法">牛顿迭代法</h2>
<p><img src="/assets/posts_jpg/算法和数据结构/算法/牛顿迭代法.jpg"
alt="牛顿迭代法" /><br />
  如图所示，计算 C 的平方根，可以理解成 <span class="math inline">\(x^2
= C\)</span> 。也就是 <span class="math inline">\(y = x^2 - C\)</span>
，当 y = 0 时，x 的值，也就是曲线和 x轴
的交点。而牛顿迭代法就是从初始值<span
class="math inline">\(x_0\)</span>，一直向交点接近。<span
class="math inline">\(x_0\)</span> 一般取 C
值即可，防止过大，或者过小。<span class="math inline">\(x_0\)</span>
和曲线的交点为 <span class="math inline">\(x_0\)</span> , <span
class="math inline">\(x{_0}{^2} - C\)</span> 。该点的切线曲率为 <span
class="math inline">\(2x_0\)</span>，因此该切线的方程式为：<span
class="math inline">\(y = 2x_0 * (x - x_0) + x{_0}{^2} -
C\)</span>，因此 <span class="math inline">\(x_1\)</span> 就是当 y =
0时的值。也就是 <span class="math inline">\(x_1 = (x_0 + C/x_0) /
2\)</span> 。也就是说，代码这样写即可:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">b <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token class-name">C</span><span class="token operator">/</span>a<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>  当两次结果，也就是上一次结果 a，和这一次结果
b，非常接近时，就可以视为结束。也就是:</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">b <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token class-name">C</span><span class="token operator">/</span>a<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>a <span class="token operator">-</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0.0000001</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
a <span class="token operator">=</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><h2 id="欧几里得算法辗转相除法">欧几里得算法(辗转相除法)</h2></li>
<li><h2 id="floyd判圈算法龟兔赛跑算法">Floyd判圈算法(龟兔赛跑算法)</h2>
<ul>
<li><h3 id="证明快慢指针-在慢指针第一圈-前相遇">证明：快慢指针
在慢指针第一圈 前相遇</h3></li>
<li><h3 id="证明快慢指针-第二次相遇-在环入口">证明：快慢指针 第二次相遇
在环入口</h3></li>
</ul></li>
<li><h2 id="摩尔投票法-多数投票法">摩尔投票法 (多数投票法)</h2>
<p><img src="/assets/posts_jpg/算法和数据结构/算法/摩尔投票算法.jpg"
alt="摩尔投票算法" /><br />
  当数组中，target出现的次数，大于一半，也就是 target的数量 大于
非target的数量，可以使用 <strong>抵消</strong> 来找到target。遇到
当前target 相等的 次数+1，和 当前target 不相等
次数-1。抵消到最后，剩下的 一定是 出现次数大于一半 的数。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> target <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> curNum <span class="token operator">:</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 当count为0时，将当前值设为target</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        target <span class="token operator">=</span> curNum<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// curNum 不等于 target 抵消相减</span>
    count <span class="token operator">+=</span> target <span class="token operator">==</span> curNum <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><h2 id="kmp字符串匹配算法">KMP字符串匹配算法</h2>
<p>  KMP算法的特点，不回溯主字符串的指针，只回溯查询的字符串的指针，实现对主字符串的一趟扫描遍历。大致流程为，文本串A
和 查询串B 从 0
位开始遍历并比较，当发生不匹配时，只回溯B串的指针到合适的位置。<br />
<img src="/assets/posts_jpg/算法和数据结构/算法/KMP字符串匹配.jpg"
alt="KMP字符串匹配" /><br />
<img src="/assets/posts_jpg/算法和数据结构/算法/KMP字符串匹配_1.jpg"
alt="KMP字符串匹配_1" /><br />
  如上图所示，当 i 和 j 指针遍历到图中所示位置时，i位 和 j位
字符不匹配，此时 <strong>i - j ~ i - 1</strong> 和 <strong>0 ~ j -
1</strong> 上的字符串肯定是匹配的，都为 aba。因此在 i
指针不动的情况下，只需要将 j 指针移动到图中的位置，继续开始匹配。而 KMP
的关键就是：当字符不匹配时，能够获得 j 指针的新位置，而实现的方法就是
<em>查询串B</em> 中 <strong>已匹配的部分(0 ~ j - 1)</strong> 的
<strong>最长公共字符串</strong> 。这个公共字符串就是指：在 0 ~ <em>j -
1</em> 范围中，符合 0 ~ k 的字符串 == <em>j - k - 1</em> ~ <em>j -
1</em> 的字符串。使用一个数组保存每一位的最长公共串长度。</p>
<ul>
<li><h3
id="动态规划解决最长公共字符串长度">动态规划解决最长公共字符串长度</h3>
<p><img src="/assets/posts_jpg/算法和数据结构/算法/KMP字符串匹配_2.jpg"
alt="KMP字符串匹配_2" /><br />
  动态规划 dp 数组，dp[m] 表示：以 m
位字符为尾的，能够构成的最长公共字符串的长度。如图所示，m
位所指向的字符为 a，<em>m - 1</em> 位的 最长公共字符串的长度为
2，也就是说 0 ~ 1 的字符串肯定和 <em>m - 2</em> ~ <em>m - 1</em>
相同，因此判断 m位 的字符 和 2坐标 的字符是否相同。<br />
  相同的话，就是在 dp[m - 1] 的值上加 1，也就是 dp[m] = dp[m - 1] +
1。<br />
<img src="/assets/posts_jpg/算法和数据结构/算法/KMP字符串匹配_3.jpg"
alt="KMP字符串匹配_3" /><br />
  如图所示，当 m 指针指向坐标 7 时，dp[m - 1] 为 3，可以得到 0 ~ 2
的字符串 和 <em>m - 3</em> ~ <em>m - 1</em> 的字符串相同。 m 位 和 3
坐标上的字符不相同，但是 2坐标的 a 和 m - 1 坐标的 a 相匹配，因此用
dp[2] 记录的长度 1，来判断 1坐标 和 m位 的字符是否相等。更详细的说，m
位的 b 无法与 m - 1 位的 a 组成长度为 4 的公共字符串，但是 m - 1 位的 a
和 前面的 2坐标的 a 相匹配，通过用前面的 a 记录的最长长度
1，来判断是否能够组成长度为 2 的字符串。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// dp[i] 表示 以 i 位结尾的，能够组成的最长公共字符串长度</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">//</span>
<span class="token keyword">int</span> preIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token operator">==</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>preIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        dp<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>preIdx<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        preIdx <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
        <span class="token comment">// 如果不匹配 且 preIdx对应的最长公共字符串为 0</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>preIdx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            dp<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            preIdx <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            <span class="token comment">// 往前查找</span>
            preIdx <span class="token operator">=</span> dp<span class="token punctuation">[</span>preIdx<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul></li>
<li><h2 id="bm字符串匹配算法">BM字符串匹配算法</h2>
<ul>
<li><h3 id="坏字符规则">坏字符规则</h3>
<p>asdfasdfasdf
移动查询串时，哪个规则移动的位数更多，就用哪个规则。</p></li>
<li><h3 id="好后缀规则">好后缀规则</h3>
<p>移动查询串时，哪个规则移动的位数更多，就用哪个规则。<br />
移动查询串时，哪个规则移动的位数更多，就用哪个规则。</p></li>
</ul></li>
<li><h2 id="马拉车manacher算法">马拉车/Manacher算法</h2>
<p>  以线性的时间复杂度解决最长回文子串的算法。<br />
<img src="/assets/posts_jpg/算法和数据结构/算法/马拉车算法_1.jpg"
alt="马拉车算法_1" /><br />
  如图所示，原字符串 <em>str</em> 添加分隔符，保证新字符串 <em>new</em>
的长度一定为 <strong>奇数</strong> ，而 <em>new</em>
的最长回文子串，去掉分隔符后也是 <em>str</em>
中的最长回文子串。<em>new</em> 去掉最左边的 # 后，每一个 <em>str</em>
的原字符都有一个 # 对应，也就是说 <em>new</em> 和 <em>str</em>
的长度转换为：<span class="math inline">\(str = (new -
1)/2\)</span>，同理，最长回文子串的长度转换也是这个。<br />
<img src="/assets/posts_jpg/算法和数据结构/算法/马拉车算法_2.jpg"
alt="马拉车算法_2" /><br />
  <em>new</em> 的 最长回文子串为 "#a#b#b#a#"，因此 <em>str</em>
中的结果为 "abba"。<br />
  以 i位 为中心，通过 <strong>中心扩散</strong>
来获得回文子串，两个指针从 <em>i - 1</em> 向左 和 <em>i + 1</em>
向右，判断字符是否相等。通过这种方法找到最长回文子串，最终的时间复杂度为
<span class="math inline">\(O(N^2)\)</span> 。马拉车算法通过 动态规划 和
回文串的对称特性，优化 中心扩散法 判断回文串时，两个指针的
<strong>起点</strong> ，避免判断回文串时，多次遍历到重复的字符。</p>
<ul>
<li><h3 id="动态规划记录步长">动态规划记录步长</h3>
<p><img src="/assets/posts_jpg/算法和数据结构/算法/马拉车算法_3.jpg"
alt="马拉车算法_3" /><br />
  dp[i]表示：以 i位 为中心的回文串的可扩展长度。如图中的 dp[8] =
4，表示该位的左右两边可延长 4 的距离，来表示长度为 9 的回文串。</p></li>
<li><h3 id="maxright-和-center-变量">maxRight 和 center 变量</h3>
<p>  maxRight
变量记录：目前回文子串能够扩展到的最右边的位置。也就是说，以之前某一位为中心的回文串，该回文串的最右边的位置。<br />
  center 变量记录：maxRight 所对应的回文串的中心。<br />
  maxRight 和 center
对应的回文串，不一定就是最长回文串，只是能够更靠近右边的回文串。</p></li>
</ul>
<p><img src="/assets/posts_jpg/算法和数据结构/算法/马拉车算法_4.jpg"
alt="马拉车算法_4" /><br />
  如图所示，当 <strong>i &gt;= maxRight</strong>
时，此时和普通中心扩散法一样，只能从 <em>i - 1</em> 和 <em>i + 1</em>
开始判断回文串。</p>
<p><img src="/assets/posts_jpg/算法和数据结构/算法/马拉车算法_5.jpg"
alt="马拉车算法_5" /><br />
  如上图所示，mirror指针 表示 i指针 的以 center
为中心的对称指针。通过对称的关系得到 mirror 和 i 转换公式为：<span
class="math inline">\(mirror = 2center - i\)</span> 。<br />
  根据图中示例解释为：dp[mirror] = 0，说明以 mirror 为中心的回文串步长为
0。根据回文串对称性可得：</p>
<ul>
<li>以 mirror 为中心：1位 和 3位 一定不相等</li>
<li>以 center 为中心：1位 和 5位 一定相等。</li>
</ul>
<p>  推导可得：3位 和 5位 一定不相等。<br />
  此时 <strong>maxRight - i &gt; dp[mirror]</strong> ，表示整个
mirror回文串 都在 center回文串 的内部，且有左边界 mirror - dp[mirror]
&gt; maxLeft。可以得到结果：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>mirror<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="/assets/posts_jpg/算法和数据结构/算法/马拉车算法_6.jpg"
alt="马拉车算法_6" /><br />
  如上图所示，当 <strong>maxRight - i = dp[mirror]</strong>
时，mirror回文串 都在 center回文串 的内部。和上面的例子一样，只是左边界
mirror - dp[mirror] = maxLeft。<br />
  根据回文串对称关系可以得到：</p>
<ul>
<li>绿色箭头的字符一定相等</li>
<li>橙色箭头的字符一定相等</li>
</ul>
<p>  推导可得：蓝色箭头的字符一定相等。同理，8 ~ 10 和 12 ~ 14
内的字符都可以通过这种方式证明相等。因此 <strong>dp[i] 至少等于
dp[mirror]</strong> 。<br />
  已知 1位 和 9位 一定不相等，1位 和 15位 一定不相等，7位 和 9位
一定相等，但是不能通过上面的条件判断 7位 和 15位
的关系。因此从这两个位置作为 <strong>起点</strong>
，进行回文串判断。所以有：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> i_left <span class="token operator">=</span> i <span class="token operator">-</span> dp<span class="token punctuation">[</span>mirror<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i_right <span class="token operator">=</span> i <span class="token operator">+</span> dp<span class="token punctuation">[</span>mirror<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="/assets/posts_jpg/算法和数据结构/算法/马拉车算法_7.jpg"
alt="马拉车算法_7" /><br />
  如上图所示，当 <strong>maxRight - i &lt; dp[mirror]</strong>
时，mirror回文串 一部分不在 center回文串 之中。mirror回文串
左半部分中，在 center回文串 内部的部分为：maxLeft ~ mirror，以 center
为中心进行转换可得：i ~ maxRight。和上面同理，根据对称的特性，i ~
maxRight 一定能够以 i 为中心 匹配成回文串。<br />
  根据回文串对称关系可以得到：</p>
<ul>
<li>绿色箭头的字符一定相等</li>
<li>蓝色箭头的字符一定相等</li>
<li>橙色箭头的字符一定不相等</li>
</ul>
<p>  推导可得：红色箭头的字符一定不相等。也就是说，i回文串
无法继续扩展。最终得到结果：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> maxRight <span class="token operator">-</span> i<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>  整理上面的条件：</p>
<ul>
<li>当 i &gt;= maxRight 时，判断起点是 i - 1 和 i + 1；</li>
<li>当 i &lt; maxRight 时
<ul>
<li>dp[mirror] &lt; maxRight - i，dp[i] = dp[mirror]；</li>
<li>dp[mirror] = maxRight - i，dp[i] = dp[mirror] 且判断起点为 i - 1 -
dp[mirror] 和 i + 1 + dp[mirror]；</li>
<li>dp[mirror] &gt; maxRight - i，dp[i] = maxRight - i；</li>
</ul></li>
</ul>
<p>  结合上述条件可以得到马拉车算法的关键为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> maxRight<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
  <span class="token keyword">int</span> mirror <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> center <span class="token operator">-</span> i<span class="token punctuation">;</span>
  <span class="token comment">/* 
  maxRight - i &lt; dp[mirror]，dp[i] = maxRight - i
  maxRight - i >= dp[mirror]，dp[i] 至少为 dp[mirror]
  相当于取 dp[mirror] 和 maxRight - i 中更小的 */</span>
  dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>mirror<span class="token punctuation">]</span> <span class="token punctuation">,</span> maxRight <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> i_left <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> i_right <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 回文串判断</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token comment">// 更新 maxRight 和 center</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> maxRight<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  maxRight <span class="token operator">=</span> i <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  center <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  原字符串 转 新字符串 时间复杂度为 <span
class="math inline">\(O(N)\)</span> 。回文串判断过程中，i_right
指针向右遍历时，基本上避免了重复遍历，每个字符只遍历了一次，时间复杂度为
<span class="math inline">\(O(N)\)</span>。最终时间复杂度为 <span
class="math inline">\(O(N)\)</span> 。</p></li>
<li><h2 id="约瑟夫环">约瑟夫环</h2>
<p>  约瑟夫环：0,1,···,n-1这 n 个数字排成一个圆圈，从数字 0
开始，每次从这个圆圈里删除第 m
个数字，然后从下一个数开始计数。求出这个圆圈里剩下的最后一个数字。<br />
  假设F(n,m)，表示 n 个数时，从第一个计数，每次删除第 m
个数，最后剩下的坐标。那么有：<br />
  设 F(n - 1, m) = x，也就是在 n - 1 个数中，最后剩下的是坐标为 x
的那个。当从坐标 0 开始 计数时，此时有 n 个数，用 F(n, m)
表示，第一次移除的数为第 m 个，坐标 m - 1，考虑到循环问题，直接用 m % n
来表示，移除后，从下一个数开始计数，坐标 m，此时还剩 n - 1 个数。</p>
<ul>
<li>F(n - 1, m) ：从 坐标0 开始计数，最终结果为 x;</li>
<li>F(n, m) ：从 坐标0 开始计数，移除第 m 个后，还剩 n - 1 个数，从 m %
n 计数。F(n, m) 等价于 从 m % n 开始计数的 F(n - 1, m);</li>
</ul>
<p>  已知，F(n - 1, m) 结果为 x。F(n, m) 结果的坐标为 ：x + m %
n。考虑到循环，所以结果为 (x + m % n) % n，最终整理可得： <span
class="math display">\[F(n, m) = (F(n - 1, m) + m) \%
n\]</span></p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法笔记_做题总结</title>
    <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AC%94%E8%AE%B0-%E5%81%9A%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ul>
<li><h1 id="小数-和-二进制">小数 和 二进制</h1>
<p>  小数部分乘2取整数部分，也就是0或1，顺序排序，得到的结果就是小数转二进制。4.125
转 二进制 就是，100.001。</p>
<ul>
<li><h2 id="科学计数法-和-二进制科学计数法">科学计数法 和
二进制科学计数法</h2>
<p><span class="math display">\[S * 10^N (1 &lt;= S &lt; 10)\]</span>
  该计数方法中，S为尾数，N为整数，用 E或e (exponent 指数) 表示 10的 N
次方：</p>
<ul>
<li><span class="math inline">\(1.23E + 7 = 1.23 * 10^7\)</span><br />
</li>
<li><span class="math inline">\(2.7E - 4 = 1.23 * 10^{-4}\)</span></li>
</ul>
<p>  二进制科学计数法同理。计算机的浮点数表示，本质上就是二进制科学计数法</p></li>
<li><h2 id="单精度浮点数">单精度浮点数</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">位数</th>
<th style="text-align: center;">符号位</th>
<th style="text-align: center;">指数位</th>
<th style="text-align: center;">尾数位</th>
<th style="text-align: center;">指数偏移量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">单精度</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">23</td>
<td style="text-align: center;">127</td>
</tr>
<tr class="even">
<td style="text-align: center;">双精度</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">11</td>
<td style="text-align: center;">52</td>
<td style="text-align: center;">1023</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">4.125</span> <span class="token operator">-></span> <span class="token number">100.001</span> 
      <span class="token operator">-></span> <span class="token number">1.00001</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token operator">^</span><span class="token number">2</span>
其中 <span class="token number">00001</span> 就是尾数，<span class="token number">2</span>就是指数，需要加上<span class="token number">127</span>偏移量。
<span class="token number">2</span> <span class="token operator">+</span> <span class="token number">127</span> <span class="token operator">-></span> <span class="token number">10000001</span>
<span class="token number">4.125</span> <span class="token operator">-></span> <span class="token number">0</span> <span class="token number">10000001</span> <span class="token number">00001000000000000000000</span>
同理
<span class="token number">0.25</span> <span class="token operator">-></span> <span class="token number">0</span> <span class="token number">01111101</span> <span class="token number">00000000000000000000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  为什么指数要加上偏移量：指数部分 也是有 <strong>正负</strong>
的，如果不做处理，那么会使得 浮点数 中有两个符号位，多了一个用来表示
指数正负 的符号位。因此加上偏移量的结果，也就是 <strong>移码</strong>
，来实现无符号整数表示。这样在比较浮点数大小时，就只需要判断一个符号位即可。指数的8位，可以直接无符号的判断大小。<br />
  为什么偏移量的值是 127：8位无符号的值范围是 0 ~ 255 (00000000 ~
11111111)，其中 00000000 和 11111111 移码，在
指数中不不使用，因此指数的范围是 1 ~ 254 (00000001 ~ 11111110) 共 254
个值。因此使用 254 的中位数，127 或 128 作为偏移量，是合理的。<br />
  如果以 128 为偏移量，那么 在指数值为 +127 (01111111) 时，结果为
11111111，因为不使用该值，相当于溢出。因此以 128
为偏移量，指数的范围是，-127 ~ 126。<br />
  如果以 127 为偏移量，那么 在指数值为 -127 (10000001) 时，结果为
00000000，因为不适用该值，相当于溢出。因此以 127
为偏移量，指数的范围是，-126 ~ 127。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">当 <span class="token number">23</span>位 尾数全为 <span class="token number">1</span> 时，尾数值最大
<span class="token number">1.11111111111111111111111</span> <span class="token operator">=</span> <span class="token number">1.9999998</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 约为 <span class="token number">2</span>
当 <span class="token number">23</span>位 尾数全为 <span class="token number">0</span> 时，尾数值最小
<span class="token number">1.00000000000000000000000</span> <span class="token operator">=</span> <span class="token number">1</span>  

因此 <span class="token number">128</span> 偏移量，浮点数的取值范围是：
<span class="token operator">-</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span><span class="token number">126</span> <span class="token operator">~</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span><span class="token operator">-</span><span class="token number">127</span> 和 <span class="token number">1</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span><span class="token operator">-</span><span class="token number">127</span> <span class="token operator">~</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span><span class="token number">126</span>。
数量为 ： <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span><span class="token number">126</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span><span class="token operator">-</span><span class="token number">127</span> <span class="token punctuation">)</span> 约为 <span class="token number">2</span> <span class="token operator">^</span> <span class="token number">128</span>。

因此 <span class="token number">127</span> 偏移量，浮点数的取值范围是：
<span class="token operator">-</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span><span class="token number">127</span> <span class="token operator">~</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span><span class="token operator">-</span><span class="token number">126</span> 和 <span class="token number">1</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span><span class="token operator">-</span><span class="token number">126</span> <span class="token operator">~</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span><span class="token number">127</span>。  
数量为 ： <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span><span class="token number">127</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token operator">^</span><span class="token operator">-</span><span class="token number">126</span> <span class="token punctuation">)</span> 约为 <span class="token number">2</span> <span class="token operator">^</span> <span class="token number">129</span>。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  由此可得，当偏移量为 127
时，取值范围更大。精度越大则取值范围越小，精度越小则取值范围越大。标准规定偏移量值为
127。</p></li>
<li><h2 id="浮点数精度问题">浮点数精度问题</h2>
<p>  32位中，1位符号位，8位指数位，23位尾数位。当出现 4.2
这种，小数部分二进制无限循环的时候，100.001100110011...，只能有23位，也就是00
0011 0011 0011 0011 0011
0|0，第24位0舍去，类似于四舍五入这种说法，也就是精度丢失。最后23位尾数位存的结果为
00 0011 0011 0011 0011 0011 0，这时候在转换成十进制 则为
4.199999809265137
  两个单精度浮点数相加的结果，位数有限，也可能发生精度丢失</p></li>
</ul></li>
<li><h1 id="二进制-优化-数量选择">二进制 优化 数量选择</h1>
<p>  假设场景下，需要取 n 个同一物品，一个一个的取，循环 n
次。除了这种方法，可以通过二进制 预处理优化。原理就是用数组保存
二进制每一位对应的十进制数，通过换一个角度的二进制表达式的方式计算获得结果。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">...</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">16</td>
<td style="text-align: center;">32</td>
<td style="text-align: center;">64</td>
<td style="text-align: center;">128</td>
<td style="text-align: center;">256</td>
<td style="text-align: center;">512</td>
<td style="text-align: center;">...</td>
</tr>
</tbody>
</table>
<p>  举例说明，23 的二进制数为，00010111，1 所在的每一位
，转为十进制就是 1、2、4、16 。对应的预处理的后的数组的
arr[0]、arr[1]、arr[2]、arr[4]。</p></li>
<li><h1 id="数学运算">数学运算</h1>
<ul>
<li><h2 id="字符串的乘法加法">字符串的乘法加法</h2>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> res <span class="token operator">=</span> num1 <span class="token operator">+</span> num2 <span class="token operator">+</span> carry<span class="token punctuation">;</span>或者 res <span class="token operator">=</span> num1 <span class="token operator">*</span> num2 <span class="token operator">+</span> carry<span class="token punctuation">;</span>
carry <span class="token operator">=</span> res <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
res <span class="token operator">=</span> res <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>  字符串运算中，不管乘法还是加法 ，上面这部分是通用的逻辑。<br />
  在乘法中，长度为n的数 和 长度为m短的数 相乘，那么结果的长度不会超过 n
+ m，不会低于 m + n -
1。因此字符串乘法时，可以利用该特点，做辅助数组，保存每一字符相乘结果 到
数组中对应位置。如，n中
i上的字符，和m中j上的字符相乘，因为字符相乘结果最大81，不会超过2位数，那么对应的结果就是在，i+j和
i+j+1，这两个位置上。也就是 res/10 在
i+j位置，res%10在i+j+1位置。可以直接参考LeetCode_43_字符串相乘。</p></li>
<li><h2 id="减法实现除法">减法实现除法</h2>
<p>  以被除数100，除数3为例。100 减 4 次 3 和 100 减 1 次
4*3，是一样的结果。因此可以通过左移除数，也就是 3 &lt;&lt; 2 或者 直接
除数乘4，来减少循环次数。需要注意的是，减法的次数
同样需要随着除数的同步移动, 也就是 减 1 次的这个 1， 1 &lt;&lt;
2。</p></li>
<li><h2 id="乘法实现x的n次幂">乘法实现x的n次幂</h2>
<p>  和减法实现除法思路相似，不使用暴力法一个一个计算。直接计算n/2次幂，再将结果相乘。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">res <span class="token operator">=</span> x<span class="token operator">^</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 注意奇偶</span>
x<span class="token operator">^</span>n <span class="token operator">=</span>  res <span class="token operator">*</span> res 或者 x<span class="token operator">^</span>n <span class="token operator">=</span> res <span class="token operator">*</span> res <span class="token operator">*</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul></li>
<li><h1 id="集合">集合</h1>
<ul>
<li><h2 id="addnull">add(null)</h2>
<p>  做题时，add(null) 和 size == 0，这两个需要理解清楚。add(null) 不是
集合为空。集合add(null)后，集合元素 + 1，该元素为空。</p></li>
<li><h2 id="泛型">泛型</h2>
<p>  用List 和 int
举例，如果返回结果是二维数组，除了生成1个二维数组，也可以泛型指定int[]，也就是
List&lt;int[]&gt;，然后List的toArray方法，转为二维数组。指定集合的泛型，只能是引用类型
或 数组类型。</p></li>
<li><h2 id="arrays.sort-和-comparator">Arrays.sort 和 Comparator</h2>
<p>  调用sort方法排序时，传comparator对象，可以处理像二维数组，或者字符的场景。需要指定Comparator泛型，类型要和数组元素类型保持一致，因为是指定类型，因此只能是引用类型或者数组类型，不能是基本类型。比如说是int[][]，那么指定类型int[]。然后重写compare方法，方法的两个参数同样需要和数组元素类型保持一致。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> o1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 当返回值 > 0 ，前一个元素 o1 和 后一个元素位置 o2 互换</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul></li>
<li><h1 id="一趟扫描遍历">一趟扫描遍历</h1>
<p>  部分算法题目中会有这个要求，这个一趟扫描需要注意的是，和for循环个数无关，如：长度为n的数组，第一个for循环，扫描n/2个元素，第二个for循环扫描剩下的元素，这任然是一趟扫描。重要的不是for循环的个数，而是一个元素在循环中只经过一次。</p></li>
<li><h1 id="二维数组中遍历ij位置周围">二维数组中遍历(i,j)位置周围</h1>
<p>  当需要遍历位置(i,j)周围，如以(i,j)为中心的九宫格，或者上下左右位置时，可以创建
(i,j)偏移量二维数组
来优化代码结构。如：对于(i,j)来说，上面位置的偏移量是
(-1，0)，左边位置的偏移量是
(0，-1)。所以遍历(i,j)周围时，可以这么实现：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 遍历九宫格</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> curI <span class="token operator">=</span> startI <span class="token operator">+</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> curJ <span class="token operator">=</span> startJ <span class="token operator">+</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 遍历上下左右</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> around <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ar <span class="token operator">:</span> around<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> curI <span class="token operator">=</span> startI <span class="token operator">+</span> ar<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> curJ <span class="token operator">=</span> startJ <span class="token operator">+</span> ar<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><h1 id="杨辉三角">杨辉三角</h1>
<p>  杨辉三角的题目前没遇到什么难的，只是记下 第n层 的公式：<br />
<span
class="math display">\[C_{n-1}^{0},C_{n-1}^{1},C_{n-1}^{0},C_{n-1}^{2},...,C_{n-1}^{n-2},C_{n-1}^{n-1}\]</span><br />
  每一层直接套这个公式就可以，没必要从第一层递推了。<br />
<span class="math display">\[C_{n}^{m} = C_{n}^{m - 1} * (n - m + 1) /
m\]</span></p></li>
<li><h1 id="搜索旋转排序数组">搜索旋转排序数组</h1>
<ul>
<li><h2 id="旋转有序数组的特点">旋转有序数组的特点</h2>
  左边，及右边有序；当要在该类数组中，搜索target时，需要考虑 mid
在左右升序位置 及 target在左右升序位置。也就是 mid target 和
数组第1位或最后1位的大小关系。直接画出图形表示。</li>
</ul></li>
<li><h1 id="前缀和">前缀和</h1>
<p>  当题目要求，计算 数组的子区间，单向链或树中的单向链路径 的
总和，类似这种的 连续子区间。大概率可以通过 前缀和
解决。前缀和的大致思路：对于 preI 为 0 ~ i 的 前缀和，preJ 为 0 ~ j
的前缀和，且 j &gt; i。那么 preJ - preI 就是 区间 i+1 ~ j 的
总和。</p></li>
<li><h1 id="子集的总和">子集的总和</h1>
<ul>
<li><h2 id="连续子区间">连续子区间</h2>
<p>  一般是前缀和</p></li>
<li><h2 id="非连续子集">非连续子集</h2>
<p>  一般是背包问题</p></li>
</ul></li>
<li><h1 id="中位数">中位数</h1>
<ul>
<li><h2 id="中位数的特点">中位数的特点</h2>
<ul>
<li>该位置左边的长度 等于 该位置右边的长度。<br />
</li>
<li>左边的最大值 小于等于 右边的最小值。</li>
</ul></li>
</ul></li>
<li><h1 id="回文串">回文串</h1>
<ul>
<li><h2 id="回文串的特点">回文串的特点</h2>
<ul>
<li>从左右两边向内遍历，两边字符相同，从左向右遍历 和 从右向左遍历
得到的结果相同。<br />
</li>
<li>从中间向两边遍历，遍历字符相同。<br />
</li>
<li>回文串去掉最左边及最右边，中间部分依旧是回文串。</li>
</ul></li>
<li><h2 id="判断回文串的方式">判断回文串的方式</h2>
<ul>
<li>从左右向内遍历。<br />
</li>
<li>从中间向外遍历。因为回文串长度有奇偶之分，因此从i点向左右两边判断是否是回文串时，除了left,right
= i以外，还需要判断left = i，right = i+1 判断偶数时的情况。<br />
</li>
<li>动态规划。在左右两边相等的情况下，判断中间部分是否为回文串。</li>
</ul></li>
</ul></li>
<li><h1 id="递归和回溯">递归和回溯</h1>
<ul>
<li><h3 id="递归回溯">递归、回溯</h3>
<p>  自己调用自己，也就是递归，属于一种代码结构；多种选择，选择其中一种，根据条件退回，再选择，也就是回溯，属于代码思想。回溯在题目中的体现，一般就是
添加一个值，相当于选择，去掉添加的值，相当于回退，在添加下一个值。算法题中涉及的回溯，最常见的就是上面的这个流程。递归
+ 回溯 一般就是 DFS 深度优先遍历。 当题目中出现 "所有符合条件的结果"
这类情况时，一般就是 dfs +
根据条件剪枝。根据题目画出树，会更加清晰。<br />
  递归需要用到栈空间，也就是空间复杂度，栈空间的消耗，和递归的深度相关。</p></li>
<li><h4 id="递归做题的一些思路">递归做题的一些思路</h4>
<p>  涉及到递归的部分，最好直接从宏观的角度写出大致的流程，及递归的出口。然后再实现或调整细节。最后根据写的代码从入口走一遍流程过下细节。涉及到递归的题，整个输入参数，就当作宏观角度，从入参获得结果，就是宏观角度的流程。同时，入参的子区间，同样也适用于这个流程，然后获得这个子区间的结果。为了方便理解，这里使用
汉诺塔 举例说明：</p></li>
</ul></li>
<li><h3 id="树结构与递归">树结构与递归</h3>
<p>  如果 递归的过程 能够用 树结构
表示，那么最终的结果，可以分为两种：<br />
1.一种通过递归获得子区间结果，结果在根节点。<br />
2.一种通过 递归+剪枝 从 0 生成结果，结果在叶节点。当题目中出现
"所有符合条件的结果" 这类情况时 中心对称数 II</p></li>
<li><h3 id="递归-和-时间超时">递归 和 时间超时</h3>
<p>  当一个题目能够使用递归实现，但是递归执行结果超时。那么该题大概率需要
动态规划
实现。根据题目的入参提示，如果参数过大，导致递归深度过高，那么递归应该就是个陷阱。</p></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>分治算法</title>
    <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!--
- ### 215_数组中的第K个最大元素  

  - #### 分治(快排)  

    - ##### 分治处理的时间复杂度计算  
&ensp;&ensp;遍历完一遍后,O(N);如果 index != k - 1。则继续分区,第二次遍历平均 O(N/2)。因此时间复杂度为 O(N) + O(N/2) + O(N/4) +....  = O(2N) = O(N)。也就是，期望时间复杂度为 O(N)。  

-->
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划 与 背包问题</title>
    <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<ul>
<li><h1 id="动态规划">动态规划</h1>
<ul>
<li><h2 id="状态表示">状态表示</h2>
<p>  一维数组，或者多维数组，单项元素所代表的内容，相当于最优子结构，如：斐波那契数列中，dp[i]
就可以表示 i 位的值。</p></li>
<li><h2 id="状态转移方程式">状态转移方程式</h2>
<p>  通过 已获得的元素 计算转换为 当前元素
的方程式，如：斐波那契数列中，dp[i] = dp[i - 1] + dp[i - 2]。</p></li>
<li><h2 id="滚动数组">滚动数组</h2>
<p>  滚动数组是对 空间复杂度 的优化。<br />
  以二维数组(i,j)为例，如果状态转移方程式的 i 维度，只和 i - 1 或 i + 1
行这类固定位置有关，和其他行的值无关。就可以去掉 i 维度，只保留 j
维度的数组，也就是直接用一维数组替代。更新一维数组的值即可。类似的，如果一维数组中
i 位置的值，只和 i - 1
这类固定位置有关，那么同样可以降一维，只用一个变量表示。如：斐波那契数列中，dp[i]
的值只和 i - 1 及 i - 2
这固定位置的值有关，因此可以用变量代替一维数组：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 相当于 dp[i - 2]</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">// 相当于 dp[i - 1]</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 相当于 dp[i] = dp[i - 1] + dp[i - 2]</span>
  <span class="token keyword">int</span> c <span class="token operator">=</span> b <span class="token operator">+</span> a<span class="token punctuation">;</span>
  a <span class="token operator">=</span> b<span class="token punctuation">;</span>
  b <span class="token operator">=</span> c<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul></li>
<li><h1 id="背包问题">背包问题</h1>
<p>  背包问题基本上是：<strong>N</strong> 个物品 和 一个总容量为
<strong>C</strong> 的背包。每个物品有：体积 <span
class="math inline">\(C_i\)</span>，价值 <span
class="math inline">\(V_i\)</span>，数量 <span
class="math inline">\(Q_i\)</span>
。将若干物品放入到背包中，追求最大值。<br />
  背包问题最基本的公式为：<br />
<span class="math display">\[dp[i][j] = max\{dp[i - 1][j],dp[i - 1][j -
C_i] + V_i\}\]</span>   dp[i][j] 表示：在容量为 j 的背包中，0 ~ i
号的物品，能够得到的最大价值。<br />
  上面的公式也就是 01背包问题 的公式，有最基本的 状态表示 、状态转移
、思路流程。根据题目场景，由该 公式 及 思路流程 进行扩展。</p>
<ul>
<li><h2 id="背包">01背包</h2>
<p>  最基本的背包问题，每个物品只有 1 个，所以只有 选择 和 不选择
两种情况。<br />
  得到 dp[i][j] 也就是上面两种情况：</p>
<ul>
<li>不选择 i号 物品：<br />
  那么 dp[i][j] 的结果和 dp[i - 1][j] 是一样的。<br />
</li>
<li>选择 i号 物品：<br />
  那么 0 ~ <em>i - 1</em> 号占据空间不能超过 j - <span
class="math inline">\(C_i\)</span> 。dp[i - 1][j - <span
class="math inline">\(C_i\)</span>] 表示 0 ~ <em>i - 1</em> 号，在容量为
j - <span class="math inline">\(C_i\)</span> 时最大的价值。因此 dp[i][j]
的结果为 dp[i - 1][j - <span class="math inline">\(C_i\)</span>] + <span
class="math inline">\(V_i\)</span> 。</li>
</ul>
<p>  结合上面两种情况，j 容量下，0 ~ i号 的最大价值为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token class-name">Ci</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token class-name">Vi</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><h3 id="滚动数组优化空间">滚动数组优化空间</h3>
<p>  在 01背包 中，dp[i][j] 在 i 维度，只和 i - 1 有关系。因此可以去掉 i
维度，用一维数组 dp[j] 实现。因为存在 dp[i - 1][j - <span
class="math inline">\(C_i\)</span>] 这个转换关系，所以在更新滚动数组
dp[j] 时，需要从大往小更新，也就是从滚动数组的右边，往 0位
的左边更新。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token class-name">C</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token class-name">Ci</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token class-name">Ci</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token class-name">Vi</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>  当一个场景和条件符合 01背包 问题时，那么 dp[i][j] 的值，基本上和
dp[i - 1][j - Ci] + Vi 有关，根据场景来判断关系。</p></li>
<li><h2 id="完全背包">完全背包</h2>
<p>  每个物品有 无限 个。在 01背包
的选择和不选择的情况下，多了选择不同数量的情况。<br />
  一个物品选择 k 个，占用 <span
class="math inline">\(k*C_i\)</span>，价值 <span
class="math inline">\(k*V_i\)</span> 。从 01背包 公式转换可得：<br />
<span class="math display">\[dp[i][j] = max\{dp[i - 1][j - k*C_i] +
k*V_i| 0&lt;=k*C_i&lt;=j\}\]</span>   和 01背包 思路一样，因为多了 k
这个变量，因此需要在 01背包 的流程中在加一个
k的循环。大致的代码流程为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token class-name">C</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">*</span><span class="token class-name">Ci</span> <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> k<span class="token operator">*</span><span class="token class-name">Ci</span><span class="token punctuation">]</span> <span class="token operator">+</span> k<span class="token operator">*</span><span class="token class-name">Vi</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  上面代码的格式，虽然是根据完全背包的公式直接实现的，但是会多次访问重复的元素，因此需要将流程优化。
<img src="/assets/posts_jpg/算法和数据结构/动态规划/完全背包_1.jpg"
alt="完全背包_1" /><br />
  如上图所示：当外层循环值为 i 时，<span
class="math inline">\(C_i\)</span> 的值为 3，内层循环指针遍历到 <span
class="math inline">\(j_2\)</span>。根据完全背包的公式来看，dp[i][<span
class="math inline">\(j_2\)</span>] 的值，为 dp[i - 1][<span
class="math inline">\(j_0\)</span>] ~ dp[i - 1][<span
class="math inline">\(j_2\)</span>]，中最大的那一项，也就是图中红色部分。<br />
  当指针遍历到 <span class="math inline">\(j_3\)</span> 时，dp[i][<span
class="math inline">\(j_3\)</span>]
的值从图中的红色部分获得。此时会发现，<span
class="math inline">\(j_2\)</span> 和 <span
class="math inline">\(j_3\)</span> 有重复部分，而
<strong>重复部分的结果</strong> ，就是蓝色格子的 dp[i][<span
class="math inline">\(j_2\)</span>]。因此流程优化成，<span
class="math inline">\(j_3\)</span> 只需要比较 dp[i - 1][<span
class="math inline">\(j_3\)</span>] 和 dp[i][<span
class="math inline">\(j_2\)</span>] 取更大那一项即可。<br />
<span class="math display">\[dp[i][j] = max\{dp[i - 1][j],dp[i][j - C_i]
+ V_i\}\]</span>   大致的代码流程为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token class-name">C</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token class-name">Ci</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token class-name">Ci</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token class-name">Vi</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><h3 id="滚动数组优化空间-1">滚动数组优化空间</h3>
<p>  思路是一样的，优化后的流程中，dp[i][j] 只和 <em>i - 1</em> 及 i维度
有关，直接去掉 i维度 即可。和 01背包 不一样的地方是，dp[i][j] 涉及到
同一维度的新值 dp[i][j - <span
class="math inline">\(C_i\)</span>]，所以滚动数组 dp[j]
的更新方向，需要从左往右更新。大致的代码为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token class-name">Ci</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token class-name">C</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token class-name">Ci</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token class-name">Vi</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>  当一个场景和条件符合 完全背包 问题时，那么 dp[i][j] 的值，基本上和
dp[i - 1][j - k*Ci] + k*Vi 等有关，根据场景来判断关系。</p></li>
<li><h2 id="多重背包">多重背包</h2>
<p>  每个物品有 <span class="math inline">\(Q_i\)</span> 个。在 01背包
的选择和不选择的情况下，多了选择不同数量的情况。<br />
  一个物品选择 k 个，占用 <span
class="math inline">\(k*C_i\)</span>，价值 <span
class="math inline">\(k*V_i\)</span> 。从 01背包 公式转换可得：<br />
<span class="math display">\[dp[i][j] = max\{dp[i - 1][j - k*C_i] +
k*V_i | 0&lt;=k*C_i&lt;=j，0&lt;=k&lt;=Q_i\}\]</span>   和 01背包
流程思路一致，加一个 k 的限制条件。大致的代码流程为：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token class-name">C</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">*</span><span class="token class-name">Ci</span> <span class="token operator">&lt;=</span> j <span class="token operator">&amp;&amp;</span> k <span class="token operator">&lt;=</span> <span class="token class-name">Qi</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> k<span class="token operator">*</span><span class="token class-name">Ci</span><span class="token punctuation">]</span> <span class="token operator">+</span> k<span class="token operator">*</span><span class="token class-name">Vi</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  这种流程有一个明显的问题，就是当物品 i 的数量 <span
class="math inline">\(Q_i\)</span> 非常大时，时间复杂度非常高。</p>
<ul>
<li><h3 id="多重背包-转-01背包">多重背包 转 01背包</h3>
<table>
<thead>
<tr class="header">
<th>物品编号</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数量</td>
<td>3</td>
<td>1</td>
<td>2</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>  将多重背包转为 01背包，可以将 i号 物品拆分成 <span
class="math inline">\(Q_i\)</span> 个同样价值、体积的物品。只是这样做对
时间复杂度 没什么优化，如果 <span class="math inline">\(Q_i\)</span>
很大，时间复杂度依然很高，只是代码结构上，可以用 01背包 流程的 2
个循环实现。</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 2%" />
<col style="width: 8%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">物品编号</th>
<th style="text-align: center;">1_1</th>
<th style="text-align: center;">1_2</th>
<th style="text-align: center;">1_3</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3_1</th>
<th style="text-align: center;">3_2</th>
<th style="text-align: center;">4_1</th>
<th style="text-align: center;">4_2</th>
<th>...</th>
<th style="text-align: center;">4_1000</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">数量</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td>...</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>  此时，多重背包问题就转为了： <span
class="math inline">\(\sum_{i}^{N}Q_i\)</span> 个物体 和 一个总容量为 C
的 01背包 问题。原dp[N - 1][C] 和 新dp[<span
class="math inline">\(\sum_{i}^{N}Q_i\)</span> - 1][C]
结果上是一样的。</p></li>
<li><h3 id="二进制-优化-转换结果">二进制 优化 转换结果</h3>
<p>  优化思路其实和 1000 试剂瓶以及 10
个小白鼠这种场景类似。每个小白鼠代表 1 位，10
位二进制数能表示出任意的一个试剂瓶编号。而二进制每一位只能是 1 或
0，刚好对应的 01背包 的 选择 或 不选择。多重背包的优化，就是通过用
二进制 表示出 任意的 <span class="math inline">\(Q_i\)</span> ，来避免
<span class="math inline">\(\sum_{i}^{N}Q_i\)</span>
个物体的出现。<br />
<img src="/assets/posts_jpg/算法和数据结构/动态规划/多重背包_1.jpg"
alt="多重背包_1" /><br />
  假设编号 4 的物品有 1000 个。那么 10 位二进制数能把 0 ~ 1000
的数都表示出来。把原本转换成 1000 个格子表示的 4号 物品，转为 10
个格子表示：</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">物品编号</th>
<th style="text-align: center;">4_1</th>
<th style="text-align: center;">4_2</th>
<th style="text-align: center;">4_3</th>
<th style="text-align: center;">4_4</th>
<th style="text-align: center;">4_5</th>
<th style="text-align: center;">4_6</th>
<th style="text-align: center;">4_7</th>
<th style="text-align: center;">4_8</th>
<th style="text-align: center;">4_9</th>
<th style="text-align: center;">4_10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">价值</td>
<td style="text-align: center;">1 * <span
class="math inline">\(V_4\)</span></td>
<td style="text-align: center;">2 * <span
class="math inline">\(V_4\)</span></td>
<td style="text-align: center;">4 * <span
class="math inline">\(V_4\)</span></td>
<td style="text-align: center;">8 * <span
class="math inline">\(V_4\)</span></td>
<td style="text-align: center;">16 * <span
class="math inline">\(V_4\)</span></td>
<td style="text-align: center;">32 * <span
class="math inline">\(V_4\)</span></td>
<td style="text-align: center;">64 * <span
class="math inline">\(V_4\)</span></td>
<td style="text-align: center;">128 * <span
class="math inline">\(V_4\)</span></td>
<td style="text-align: center;">256 * <span
class="math inline">\(V_4\)</span></td>
<td style="text-align: center;"><strong>489</strong> * <span
class="math inline">\(V_4\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">体积</td>
<td style="text-align: center;">1 * <span
class="math inline">\(C_4\)</span></td>
<td style="text-align: center;">2 * <span
class="math inline">\(C_4\)</span></td>
<td style="text-align: center;">4 * <span
class="math inline">\(C_4\)</span></td>
<td style="text-align: center;">8 * <span
class="math inline">\(C_4\)</span></td>
<td style="text-align: center;">16 * <span
class="math inline">\(C_4\)</span></td>
<td style="text-align: center;">32 * <span
class="math inline">\(C_4\)</span></td>
<td style="text-align: center;">64 * <span
class="math inline">\(C_4\)</span></td>
<td style="text-align: center;">128 * <span
class="math inline">\(C_4\)</span></td>
<td style="text-align: center;">256 * <span
class="math inline">\(C_4\)</span></td>
<td style="text-align: center;"><strong>489</strong> * <span
class="math inline">\(C_4\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">数量</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">...</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>  4 号物品有 1000 个，而 9 位二进制数能表示出 <em>0 ~ 511</em>
任意一个数，所以最后一个分到的 <em>1000 - 511</em> 个。此时 4
号物品转换成了 10 个物品，01背包的 选择 或 不选择 就相当于在该位置 1 或
0 。置为 1 的位置计算得到的结果，就是 4 号物品取的个数。<br />
  对于 i号，体积 <span class="math inline">\(C_i\)</span>，价值 <span
class="math inline">\(V_i\)</span>，数量 <span
class="math inline">\(S_i\)</span> 的物品，转换后可得：</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">物品编号</th>
<th style="text-align: center;">i_1</th>
<th style="text-align: center;">i_2</th>
<th style="text-align: center;">i_3</th>
<th style="text-align: center;">...</th>
<th style="text-align: center;">i_n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">价值</td>
<td style="text-align: center;">1 * <span
class="math inline">\(V_i\)</span></td>
<td style="text-align: center;">2 * <span
class="math inline">\(V_i\)</span></td>
<td style="text-align: center;">4 * <span
class="math inline">\(V_i\)</span></td>
<td style="text-align: center;">...</td>
<td style="text-align: center;"><span class="math inline">\((S_i -
(2^{n-1} - 1))\)</span> * <span class="math inline">\(V_i\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;">体积</td>
<td style="text-align: center;">1 * <span
class="math inline">\(C_i\)</span></td>
<td style="text-align: center;">2 * <span
class="math inline">\(C_i\)</span></td>
<td style="text-align: center;">4 * <span
class="math inline">\(C_i\)</span></td>
<td style="text-align: center;">...</td>
<td style="text-align: center;"><span class="math inline">\((S_i -
(2^{n-1} - 1))\)</span> * <span class="math inline">\(C_i\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;">数量</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">...</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>  转换后，新的 n 个物品，能表示取 0 ~ <span
class="math inline">\(S_i\)</span> 个的原 i 号物品。n 和 <span
class="math inline">\(S_i\)</span> 的关系有：<span
class="math inline">\(2^{n - 1} &lt;= S_i &lt; 2^n\)</span> 。<br />
  在 多重背包 整个流程中，不需要在意一个物品究竟取了多少个，关键在于
<strong>转换成了01背包</strong> 且
<strong>优化了空间和时间复杂度</strong> 。</p></li>
</ul></li>
</ul></li>
</ul>
<!-- ### 原题
 279.完全平方数
 322.零钱兑换
 416.分割等和子集
 494.目标和 -->
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>滚动数组</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<!--
- ### 134_加油站  
#### 300. 最长递增子序列
-->
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS 和 juc中并发工具类</title>
    <url>/Java/java%E5%9F%BA%E7%A1%80/juc-AQS/</url>
    <content><![CDATA[<ul>
<li><h1 id="abstractqueuedsynchronizer类">AbstractQueuedSynchronizer类
<span id="jump_aqs"></span></h1>
<ul>
<li><h2 id="底层数据结构">底层数据结构</h2>
<p>  AQS类底层是一个双向链表。每个节点相当于一个线程。通过 CAS 修改
volatile 字段 state 的值，来表示 AQS
的同步状态。state可以理解成所有线程争取的资源。<br />
  节点类Node，内部字段 <strong>waitStatus</strong>
表示当前节点的状态。字段 next，pre 保存 Node双向链 结构，也就是
<strong>同步队列</strong> 。字段 nextWaiter 保存 Node单向链 结构，也就是
<strong>条件队列</strong> 。<br />
  Node 类的 waitStatus ：</p>
<ul>
<li>0 ： 当该 Node
节点初始化时的默认值，也可表示线程执行完释放锁。<br />
</li>
<li>1 CANCELLED ：表示当前节点所对应的线程获取锁申请取消。<br />
</li>
<li>-2 CONDITION ：表示该节点对应线程等待唤醒(相当于 wait，notify
)。或者说该节点是 <strong>Condition条件队列</strong> 中的节点。<br />
</li>
<li>-1 SIGNAL ：表示该节点对应线程已经准备好，等待资源释放。<br />
</li>
<li>-3 PROPAGATE ：只有读模式下才有会使用。</li>
</ul></li>
<li><h2 id="head-和-tail-和-cas时的偏移量">head 和 tail 和
CAS时的偏移量</h2>
<p>  AQS内，有字段 <strong>head</strong> 和 <strong>tail</strong>
表示双向链表的头节点和尾节点。其中head节点只是一个虚节点，初始化时执行Node无参构造方法，
<strong>虚节点中thread字段和prev字段都为null</strong>
。head的next节点才是队列中的第一个线程节点。当第一个线程节点获得锁时
(相当于CAS修改state成功并把ownerThread字段指向了该线程)
，会通过<strong>setHead()</strong>方法将该节点设为新head并把head节点变为虚节点。<br />
  和head直接修改不同，字段tail通过
<strong>CAS操作修改指向的节点</strong>
。因为head只要把获得锁的线程节点设为虚节点就可以，不受到多线程影响。但是tail会受到
<strong>其他线程节点进入该双向链表</strong> 的影响。<br />
<img src="/assets/posts_jpg/Java/java-knowledge/通过AQS类看CAS操作.jpg"
alt="通过AQS类看CAS操作" /><br />
  上图是CAS操作的大致过程。可以看到，某个字段的地址 = baseAddress +
该字段的offset。偏移量offset就相当于字段的定位。在java中除了基本类型保存的value为值，其他的引用型变量保存的都是指向的对象的地址。在AQS类中，tail字段的value就是Node对象的地址，通过CAS变更value的值。</p></li>
<li><h2 id="addwaiter方法-和-acquirequeued方法">addWaiter()方法 和
acquireQueued()方法</h2>
<p>  AQS类acquire()方法内，除了再调用tryAcquire()方法后，如果没能获取锁，就会把线程作为节点加入到链表中。先调用addWaiter()方法将Node加入，方法内通过
<strong>CAS + 自旋</strong> 确保对象一定添加成功。<br />
  acquireQueued()方法，通过for死循环自旋，让线程节点只有 <strong>获得锁
或 挂起</strong> 两种结果。该方法的 <strong>出口</strong>
就是获得锁。<br />
  方法 <strong>shouldParkAfterFailedAcquire()</strong>
，判断该节点是否要挂起。在该方法中，会判断当前节点的有效的前置节点waitStatus是否为-1，也就是是否在等待资源。因为正常情况下，只有前置节点解锁后，当前节点才能被唤醒。因此需要确定前置节点是否有效，也就是前置节点是否是处于等待资源释放。假设：head节点的线程释放锁时，先把waitStatus置为0，然后unPark()方法唤醒下一个线程。但此时另一个线程非公平锁抢占成功，因为tryAcquire()方法成功，所以没必要加入到等待队列中。此时head节点不变，被唤醒的线程先将head的waitStatus置为-1，然后park()方法挂起。抢占线程释放锁时，head系节点没变，release()方法还是会唤醒head的下一个有效节点。<br />
  方法 <strong>parkAndCheckInterrupt()</strong>
，通过Unsafe的park()方法挂起线程。被park()方法挂起的线程，会被
<strong>unPark() 和 interrupt()</strong>
方法唤醒。unPark()只有前置节点解锁时才会调用，也就是说在链表中只有前面的那个节点才能唤醒在它后面的那个节点。interrupt()方法，是将调用该方法的线程设置为
<strong>中断</strong> 标志。该方法只是一个 <strong>标志</strong> ，并
<strong>不是直接中断一个线程</strong>
。中断标志具体使用根据需求来实现。在acquire()方法中，并不会对中断标志做出反应。在该方法中，中断标志的作用是看线程在挂起时，是否被中断过，因为interrupt()也会唤醒挂起的线程。acquireInterruptibly()方法就会相应中断标志。该方法两个出口获得锁或者抛出InterruptedException异常。如果在等待锁过程中因为interrupt()方法被唤醒，在自旋中就会发现中断标志位为true，然后抛出异常，退出获取锁状态。</p></li>
</ul></li>
<li><h1 id="从-reentrantlock-看aqs的acquire方法流程">从 ReentrantLock
看AQS的acquire()方法流程</h1>
<p><img
src="/assets/posts_jpg/Java/java-knowledge/ReentrantLock获取锁1.jpg"
alt="ReentrantLock对象获取锁" /><br />
  当ReentrantLock对象调用lock()方法后，如果tryAcquire()方法返true，则说明获得锁成功。就没必要继续执行addWaiter()等方法。</p>
<p><img
src="/assets/posts_jpg/Java/java-knowledge/ReentrantLock获取锁2.jpg"
alt="tryAcquire失败加入队列" /><br />
  当tryAcquire()方法返回false时，才执行addWaiter()和acquireQueue()方法。addWaiter()将线程添加到链表中。acquireQueue()方法内for死循环尝试获取锁。</p>
<p><img
src="/assets/posts_jpg/Java/java-knowledge/ReentrantLock获取锁3.jpg"
alt="shouldParkAfterFailedAcquire内部" /><br />
  shouldParkAfterFailedAcquire()方法内，只有前置节点的waitStatus为-1，才会挂起线程，等待唤醒。因为只有前置节点会unPark()它后面的那个节点。因此要确定前置节点不处于取消状态。</p></li>
<li><h1 id="aqs中的-同步队列-和-条件队列">AQS中的 同步队列 和
条件队列</h1>
<p>  AQS中的同步队列，就是Node节点的next、prev字段保存的双向链表结构。在Java8中，条件队列是Node节点的
<strong>nextWaiter</strong>
字段保存的单向链表结构。在之后的版本中，nextWaiter字段从Node类中独立，条件队列由Node子类ConditionNode类节点组成，总体思路不变。<br />
  Condition相当于 <strong>Lock实现类的wait、notify机制</strong>
。通过调用newCondition方法，创建一个 <strong>ConditionObject</strong>
对象。一个ConditionObject对象相当于一个条件队列。每调用一次方法，生成一个条件队列。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractOwnableSynchronizer</span>
    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">// 同步队列头节点，head的next才是同步队列中的第一个线程节点</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> head<span class="token punctuation">;</span>

    <span class="token comment">// 同步队列尾节点</span>
    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token class-name">Node</span> tail<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConditionObject</span> <span class="token keyword">implements</span> <span class="token class-name">Condition</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 条件队列的头节点</span>
        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> firstWaiter<span class="token punctuation">;</span>
        <span class="token comment">// 条件队列的尾节点</span>
        <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">Node</span> lastWaiter<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  Condition的await方法，就相当于wait。signal方法，就相当于notify。当线程能够执行到Condition的await方法，也就表示该线程正在运行，也就是指的
<strong>同步队列中的head节点</strong>
。而await的原理，就是释放掉当前state资源，并唤醒head的next节点，且
<strong>生成一个waitStatus为CONDITION的新节点</strong>
，并加入到条件队列中，通过park方法挂起。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 创建当前线程的新节点，状态值为CONDITION，并加入到条件队列中</span>
      <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 释放state资源并唤醒下一个线程节点，并保存释放的值，以用于被唤醒后再次竞争锁时的state值</span>
      <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 线程是否中断标志位；0:没有中断</span>
      <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      <span class="token comment">// 如果该节点没在同步队列中，则挂起。直到其他线程的signal方法，唤醒加入到同步队列中。</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token comment">// interrupt方法也能唤醒线程，判断线程是否因interrupt而唤醒</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
              <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">&#125;</span>
      <span class="token comment">// 唤醒后，重新竞争state</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> <span class="token constant">THROW_IE</span><span class="token punctuation">)</span>
          interruptMode <span class="token operator">=</span> <span class="token constant">REINTERRUPT</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// clean up if cancelled</span>
          <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
          <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  调用signal方法，从条件队列的头节点，也就是firstWaiter开始，唤醒一个线程。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            lastWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果该first节点唤醒失败，就唤醒下一个节点</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
             <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">// 如果唤醒失败，就表示该节点的状态不是CONDITION，就是说该线程状态为CANCELLED</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">CONDITION</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 该节点加入到同步队列中</span>
    <span class="token class-name">Node</span> p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span><span class="token constant">SIGNAL</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><h1 id="juc包中的工具类">juc包中的工具类</h1>
<p>  总的来说，juc包中，涉及到AQS的类，基本思路都大致一致。通过AQS的字段
<strong>state</strong> 的值来改变线程的状态。<br />
  CountDownLatch类中，state大于0，则执行await()方法的线程进入AQS队列。其他线程执行countDown()方法state-1，直到state为0。<br />
  Semaphore类中，state的值-acquire时的入参，如果小于0，则线程节点添加到AQS队列中。如果大于等于0，则相当于获得了锁。</p>
<ul>
<li><h2 id="多线程流程顺序控制">多线程流程顺序控制</h2></li>
<li><h2 id="多线程数据交互">多线程数据交互</h2></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>juc</tag>
        <tag>AQS</tag>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title>cpu缓存模型、java内存模型 和 java中的volatile</title>
    <url>/Java/java%E5%9F%BA%E7%A1%80/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8Cvolatile/</url>
    <content><![CDATA[<ul>
<li><h1 id="java内存模型-和-指令重排">Java内存模型 和 指令重排</h1>
<ul>
<li><h2 id="cpu缓存模型">cpu缓存模型</h2>
<p>  因为cpu处理数据速度很快，而cpu从内存获得数据的速度 和
cpu处理速度差距大
(大约差了100倍)。从内存中获取数据的速度无法跟上cpu执行速度影响了效率，因此需要缓存来提高获得数据的效率。<br />
<img src="/assets/posts_jpg/Java/java-knowledge/cpu缓存模型.jpg"
alt="cpu缓存模型" /><br />
  当cpu需要处理数据时，寄存器会先在L1缓存中找，没找到再依次往下。当用到内存中的某个数据时，会把该数据加到缓存中，下次直接从缓存中找到即可，提高效率。其中
<strong>寄存器、L1 、L2缓存是cpu内部</strong> 的，而
<strong>L3缓存、内存是cpu共享</strong> 的。L1和L2缓存是私有的，因此
<strong>cpu核-1只能访问自己的L1和L2缓存</strong>
，不能访问其他核的L1和L2缓存。</p></li>
<li><h2 id="java内存模型">java内存模型</h2>
<p>  java内存模型-JMM，也就是java多线程内存模型。JMM是
<strong>基于cpu缓存模型建立</strong> 的。<br />
<img src="/assets/posts_jpg/Java/java-knowledge/Java多线程内存模型.jpg"
alt="java内存模型" /></p></li>
<li><h2 id="线程缓存主内存间的交互">线程、缓存、主内存间的交互</h2>
<p><img src="/assets/posts_jpg/Java/java-knowledge/线程内存间交互.jpg"
alt="内存间交互" /><br />
  内存线程间的交互有8个命令：</p>
<ul>
<li>lock 锁定 ：作用于 <strong>主内存数据</strong>
，将该数据表示为一个线程独占。当某个线程lock了一个变量，会
<strong>清除缓存中的该变量</strong> 。<br />
</li>
<li>unlock 解锁 ：作用于 <strong>主内存数据</strong>
，将该数据解锁，解锁后才能有其他线程上锁。unlock
之前，要把缓存中的值同步到主内存中，即要执行store，write指令。<br />
</li>
<li>read 读取 ：作用于 <strong>主内存数据</strong>
，将数据读取到缓存中。一个数据被 read 之后，必被 load 到缓存中。<br />
</li>
<li>load 载入 ：作用于 <strong>缓存数据</strong> ，将从 read
中读到的数据，保存到缓存中。<br />
</li>
<li>use 使用 ：作用于 <strong>缓存数据</strong>
，将该数据传递给执行引擎。<br />
</li>
<li>assign 赋值 ：作用于 <strong>缓存数据</strong>
，将执行引擎的数据赋值到缓存中。<br />
</li>
<li>store 存储 ：作用于 <strong>缓存数据</strong>
，将缓存的值传到主内存中。数据被 store 后，必被 write 到主内存中。<br />
</li>
<li>write 写入 ：作用于 <strong>主内存数据</strong> ，将从 store
得到的值保存到主内存中。</li>
</ul>
<p>  当从内存中读取某个数据时，流程为
read，load，use。当把值写入到内存时，流程为
assign，lock，store，write，unlock。</p></li>
<li><h2 id="指令重排">指令重排</h2>
<p>  为了提高性能编译器和cpu会进行优化，对执行的指令进行重排序。该行为可能会改变执行顺序，就导致执行时的顺序不一定是源码中的顺序。<br />
<img src="/assets/posts_jpg/Java/java-knowledge/证明重排序存在.png"
alt="重排序的存在" /><br />
  上面的代码，线程one的两条语句没有依赖关系，线程two的两条语句没有依赖关系。在不存在重排序的这个前提下，对于结果
x 和 y 来说，只应该有(1,0) 或 (0,1) 或
(1,1),这三种结果。如果出现了(0，0)，就表示两个线程的执行顺序，至少有一个发生了重排序。<br />
  重排序会遵守as-if-serial语义和happens-before原则：</p>
<ul>
<li><h3 id="as-if-serial语义">as-if-serial语义</h3>
<p>  不管怎么重排序，对 <strong>单线程</strong> 本身的
<strong>执行结果不能改变</strong>
。上面的代码中，one线程和two线程的内部两条语句没有依赖关系，因此重排序不会改变结果。</p></li>
<li><h3 id="happens-before原则">happens-before原则</h3>
<p>  操作1 happens-before
操作2，表达的是前一个操作的执行结果，对后续操作可见。无论操作1和操作2是否在同一线程，happens-before保证操作1结果对操作2可见。</p></li>
</ul></li>
</ul></li>
<li><h1 id="缓存和指令重排-对多线程的影响">缓存和指令重排
对多线程的影响</h1>
<p>  缓存的存在弥补了内存获得数据速度跟不上执行速度的不足。但是，当计算机非单核单cpu时，每个核都有自己的寄存器和L1，L2缓存。多核cpu中，就会存在多个私有缓存，每个核只能访问自己的私有缓存。因此线程对数据的修改，就可能造成缓存不一致。<br />
  就像上面证明重排序存在的代码一样，单个线程中内部两条指令不存在依赖，但是存在对另一条线程中指令的依赖。因此在多线程时，重排序可能会对数据有影响。</p></li>
<li><h1 id="volatile的特点">volatile的特点</h1>
<ul>
<li><h2 id="可见性">可见性：</h2>
<p>  在写入volatile变量时，会将值写入内存。在读volatile变量时，会从内存中读取，以此来保证值变更的可见性。相当于告诉JVM，volatile变量不可靠，该变量的值在寄存器中不确定，需要从主存中读取。</p></li>
<li><h2 id="有序性">有序性：</h2>
<p>  禁止重排序来保证有序性。当遇到volatile修饰的变量的读操作或写操作时，源码中在其前面的操作全部完成。同时该次操作的结果，对在其后面的操作可见。</p></li>
<li><h2 id="不保证原子性">不保证原子性：</h2>
<p>  内存交互的 8 个命令是原子性的。假设当 volatile 变量
a，有两个线程执行 a++ 时。两个线程都执行了 use
命令，将缓存中的数据传给执行引擎，在执行引擎中 +1。但是 线程1 在 assign
之前失去时间片，线程2 获得时间片，然后执行
assign-lock-store-write-unlock
同步到主内存中。因为缓存一致性，其他线程通过
<strong>总线嗅探机制</strong> 知道该值的修改，并将缓存中的值失效，下次再
use 命令时，要先 read-load 才行。<br />
  但是，线程1 停留在 assign 之前，在该缓存数据值失效前，已经 use
了。只有在下次 use 时，才会read-load。因此丢失了一次 +1
数据。不具备原子性。<br />
  也就是说，单个变量的赋值，读取操作是有原子性的。如：x = 10；x +
1。但是当涉及到多个操作，那么就不保证原子性如：x = x + 1；y =
x；这些操作中包含了读取和赋值两个操作。而多步操作，正如上面所说的，在
use 之后，assign 之前，缓存失效，那么就会造成数据丢失等问题。</p></li>
</ul></li>
<li><h1 id="volatile的实现">volatile的实现</h1>
<ul>
<li><h2 id="字节码层">字节码层</h2>
<p>  volatile关键字在字节码中，Access Flags(访问标志)为
0xx0040，就是表示该字段为volatile。</p></li>
<li><h2 id="虚拟机规范层">虚拟机规范层</h2>
<p>  内存屏障相当于将操作用一个屏障隔开，而执行屏障后面的操作之前，屏障前边的已经执行完了。也就是在屏障前边的操作
不能和 在屏障后边的操作 重排序。<br />
  JVM将内存屏障分为四类 <strong>规范</strong> (不是实现) ：</p>
<ul>
<li><h3 id="loadload屏障">LoadLoad屏障</h3>
<p>  在读读操作间加LoadLoad屏障，禁止两个读操作重排序。在volatile变量
<strong>读操作之后</strong> ，添加LoadLoad屏障。在volatile读
后添加该屏障，禁止 <em>该volatile读</em> 和 后续的 <em>读操作</em>
的重排序。</p></li>
<li><h3 id="loadstore屏障">LoadStore屏障</h3>
<p>  在读写操作间加LoadStore屏障，禁止两个操作重排序。在volatile变量
<strong>读操作之后</strong> ，添加LoadStore屏障。在volatile读
后添加该屏障，禁止 <em>该volatile读</em> 和 后续的 <em>写操作</em>
的重排序。</p></li>
<li><h3 id="storestore屏障">StoreStore屏障</h3>
<p>  在volatile变量 <strong>写操作之前</strong>
，添加StoreStore屏障。在volatile写 前添加该屏障，保障在
<em>该volatile写</em> 之前，前面的写操作结果对其可见。</p></li>
<li><h3 id="storeload屏障">StoreLoad屏障</h3>
<p>  在volatile变量 <strong>写操作之后</strong>
，添加StoreLoad屏障。在volatile写 后添加该屏障，确保
<em>该volatile写</em> 的结果，对后面的读写操作可见。</p></li>
</ul>
<p>  不同的 cpu 硬件，对该 JVM 内存屏障规范的实现不同。</p></li>
<li><h2 id="虚拟机汇编语言层">虚拟机汇编语言层</h2>
<p>  lock汇编前缀：volatile写操作时 ( volatile读操作没有lock前缀
)，JVM会在汇编指令加一个lock前缀。前缀作用就相当于，上面的八个内存交互操作中的lock命令。<br />
  当处理器接收到 lock 前缀的指令，会执行：</p>
<ul>
<li>将缓存的值写入到主内存中，也就是内存交互时的lock-store-write-unlock。<br />
</li>
<li>写入主内存的操作，使得其他缓存中的值失效，也就是缓存一致性协议。<br />
</li>
<li>提供内存屏障的实现。</li>
</ul></li>
<li><h2 id="cpu层">cpu层</h2>
<p>  缓存一致性协议：当某个线程将缓存里的值进行了修改，会马上将该值同步到主内存中，而其他线程通过
<strong>总线嗅探机制</strong>
知道该值的修改，然后将自己缓存中的该数据失效。<br />
  MESI协议中，缓存和内存数据交换单位为Cache
Line。cpu核可以观察到自己或者其他核对Cache Line的操作。Cache
Line有四种状态：M 已修改、E 独占、S 共享、I 已失效。</p>
<ul>
<li><strong>M</strong> 已修改 ：cpu核操作中修改了数据，其他cpu核的Cache
Line为I状态。缓存和内存中数据不一致。<br />
</li>
<li><strong>E</strong> 独占
：从内存中获得数据添加到缓存中，其他cpu核没有该缓存，即为独占状态。缓存核内存中数据一致。<br />
</li>
<li><strong>S</strong> 共享
：其他cpu核中也有该缓存，缓存内存中数据一致。<br />
</li>
<li><strong>I</strong> 已失效 ：该Cache Line
已失效，缓存内存中数据不一致。</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>cpu缓存模型</tag>
        <tag>java内存模型</tag>
        <tag>volatile</tag>
        <tag>缓存一致性协议</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习笔记</title>
    <url>/Java/java%E5%9F%BA%E7%A1%80/java-A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!-- java中 局部变量的生命周期 随着方法结束而销毁。  
     外部类 和 内部类 同级，也就是 内部类对象 不会随着 方法结束 而被回收，当没用被引用时才会被回收。  
     如果内部类对象 需要 用到 局部变量，那么生命周期的 不一致 会导致，内部类对象 访问了 不存在的变量。  
     因此java中，会复制局部变量 作为内部类 成员变量 以供 内部类对象使用，为了保证 原局部变量 和 复制的变量 数据一致，必须使用 final，来保证 变量的值 或者 引用 不被改变


     不同的操作系统，机器码的识别不同，java源码， 编译成 jvm 识别的字节码，然后由 jvm 编译成 对应的 机器码，从而实现跨平台


     java asser
     java 动态编译
     IO，字节流，字符流，NIO
     lambuda
     @ 注解 及 原理 及 自定义注解
 -->
<ul>
<li><h1 id="jdk-21-新特性">JDK 21 新特性</h1></li>
<li><h1 id="jdk-17-新特性">JDK 17 新特性</h1></li>
<li><h1 id="java中的锁分类">java中的锁分类</h1>
<p>  在多线程并发操作中，常见并发控制方式就是锁。锁根据并发控制策略，可以分为
悲观锁、可重入锁 等。<strong>并发控制策略是设计思想</strong>
，不同的策略之间不完全互斥，一个具体的实现可能包含多种策略。如
synchronized 相当于：悲观、可重入、排他 。</p>
<ul>
<li><h2 id="是否给资源上锁的设计分为">是否给资源上锁的设计分为：</h2>
<ul>
<li><h3 id="悲观锁">悲观锁</h3>
<p>  就是认为一定有其他线程来修改数据，因此给获取到的数据加锁，防止其他线程进行修改。悲观锁
的特点是先获取锁，然后再操作。<br />
  在 java 中，<em>synchronized</em> 和 <em>Lock</em>
实现类都是悲观锁。像 <em>排他锁</em> ，<em>共享锁</em>
等分类算是悲观锁的更详细的划分。</p></li>
<li><h3 id="乐观锁">乐观锁</h3>
<p>  不会给数据加锁，而是通过修改数据时先判定该数据是否被别的线程修改，如果没有则更新数据。乐观锁
的特点是先操作，然后再判断该操作是否能行。乐观锁 在java中 通常用 CAS(
compare and swap )实现，在AtomicInteger等类中，就使用到了CAS +
自旋。</p></li>
</ul></li>
<li><h2
id="给资源上锁失败后的行为划分为">给资源上锁失败后的行为划分为：</h2>
<ul>
<li><h3 id="非自旋锁">非自旋锁</h3>
<p>  在竞争资源失败后，线程会进入阻塞状态，等待唤醒。线程的 阻塞 或 唤醒
都需要操作系统的介入，需要切换cpu状态 ( <strong>线程上下文切换</strong>
)。 <strong>cpu上下文切换</strong>
就是保存前一个任务的cpu上下文(程序计数器和cpu寄存器)，然后加载新任务的cpu上下文，跳转到新程序计数器所指的位置，执行新任务。</p></li>
<li><h3 id="自旋锁">自旋锁</h3>
<p>  在竞争资源失败后，会通过自旋操作，不放弃cpu时间片，尝试获取资源，这样做可以减少cpu切换。</p></li>
</ul></li>
<li><h2
id="其他线程能否给已上锁资源上锁划分为">其他线程能否给已上锁资源上锁划分为：</h2>
<ul>
<li><h3 id="共享锁">共享锁</h3>
<p>  可以在已经加了共享锁的资源上继续加上共享锁，不能加在上了排他锁的资源上。ReentrantReadWriteLock内部类ReaderLock是在java中的具体实现。</p></li>
<li><h3 id="排他锁">排他锁</h3>
<p>  不能加在上了共享锁或排他锁的资源上，只能加在没有锁的资源上。ReentrantReadWriteLock
内部类 WriteLock 是 java 中的具体实现。<br />
  ReentrantReadWriteLock 内部类 Sync 是实现锁操作的关键，Sync类
是AbstractQueuedSynchronizer类 的子类，其中 int型 字段 state
表示资源上锁的数量。state共32位，高16位表示读锁数量，低16位表示写锁数量。因此读锁或写锁最多能上2<sup>16</sup>-1
= 65535个。</p></li>
</ul></li>
<li><h2 id="竞争资源时是否排队划分为">竞争资源时是否排队划分为：</h2>
<ul>
<li><h3 id="公平锁">公平锁</h3>
<p>  线程在给打算给资源上锁时，直接加入到等待队列中，只有当自己是队列中第一个时，才可以给资源上锁，其他线程等待。Lock实现类的内部类FairSync(Sync子类)是java中公平锁的具体实现。公平锁
上锁的方法比 非公平锁
多个调用hasQueuedPredecessors()判断等待队列情况。</p></li>
<li><h3 id="非公平锁">非公平锁</h3>
<p>  线程打算给资源上锁时，先尝试上锁获取资源，失败了后再加入到等待队列。非公平锁
直接尝试获取资源可以省略线程的阻塞状态和唤醒状态的变更造成的cpu切换状态的消耗。线程在尝试获取锁时本来就处于获取到cpu时间片的运行状态，如果切换到阻塞状态就是上面提到的cpu线程上下文切换。Lock实现类的内部类
NonFairSync(Sync子类) 是java中非公平锁的具体实现。Lock实现类默认内部sync
= new NonFairSync()。<br />
  java中接口 Lock
的实现类，通过调用Sync的实例实现上锁操作，抽象类Sync有两个子类，NonFairSync和FairSync，Lock的实现类
默认NonFairSync，也即 Sync sync = new NonFairSync() 。Lock接口的
tryLock()方法也就是调用Sync类的抽象方法tryAcquire()方法，具体由两个子类实现。</p></li>
</ul></li>
<li><h2
id="线程是否可以多次获得同一把锁划分为">线程是否可以多次获得同一把锁划分为：</h2>
<ul>
<li><h3 id="可重入锁">可重入锁</h3>
<p>  允许线程中的流程多次获得同一个锁，防止内部给同一个锁上锁失败造成死锁。synchronized关键字还有ReentrantLock是java中可重入锁的具体实现。AbstractQueueSynchronizer的state字段表示上了多上锁。</p></li>
<li><h3 id="不可重入锁">不可重入锁</h3>
<p>  线程流程不能再获取同一个锁，当流程中尝试上锁同一个资源时，无法获取，当前线程也无法释放，所以会造成死锁。线程池ThreadPoolExecutor类中的内部类
Worker 就是非可重入锁，继承AQS类，没有加可重入判定。<br />
  Worker类继承AQS类实现Runnable接口，内部还有个Thread对象执行重写的run方法，相当于线程池中的
执行任务线程。当线程池变为SHUTDOWN状态时，要中断空闲线程。判定空闲线程的方法就是tryLock()，worker获得任务要执行时，会先
worker.lock() 来上锁。如果tryLock() 为 false，就表示这个 worker
对象正在执行任务不能中断，因此要用不可重入锁。</p></li>
</ul></li>
<li><h2 id="synchronized关键字">synchronized关键字</h2>
<p>  synchronized关键字，即同步锁，对于synchronized的代码块，不应该理解成synchronized锁住了这个代码块，而是
<strong>执行这段代码时需要获得同步锁</strong>
，synchronized锁住的是对象，而锁保存在对象头的 <strong>Mark
Word</strong> 中。synchronized在 class文件也就是字节码表示中，是
<strong>monitorenter</strong> 和 <strong>monitorexit</strong>
指令。<br />
  Mark Word在32位Jvm中长度就是32位，在64位Jvm中就是64位。Mark
Word默认保存的是对象的
hashcode，分代年龄，锁标志位等，也就是没有遇到同步锁时存储的数据。Mark
Word的数据会随着锁标志位的变化而变化。<br />
<img src="/assets/posts_jpg/Java/java-knowledge/MarkWord示意图.jpg"
alt="MarkWord示意图" /><br />
  根据上图所示，synchronized关键组锁的是对象，而该对象的状态在Mark
Word中。</p>
<ul>
<li><h3 id="无锁">无锁</h3>
<p>  无锁状态就是一个对象的默认状态，也就是没有遇到synchronized关键字的对象。其中Mark
Word保存的是hashcode
对象年龄等。标志位是01，和偏向锁一样，偏向锁和无锁状态通过是否偏向锁位
0和1区分。因为分代年龄是4位，因此对象年龄最大值15。</p></li>
<li><h3 id="偏向锁">偏向锁</h3>
<p>  当无锁状态的对象，被 <strong>一个线程上锁</strong> 而
<strong>不存在多线程竞争</strong> 时，会从无锁状态升级成偏向锁状态。
<strong>锁可以升级不能降级，但是偏向锁可以重置为无锁状态</strong>
。当无锁态升级到偏向锁时，原来无锁时的Mark Word中hash code等数据会
<strong>备份到获得锁的线程的栈的栈帧中</strong> (
栈是线程独有，栈帧元素的入栈出栈是方法的执行和结束，线程遇到synchronized代码块时也会在某个方法中，则
<strong>备份数据就保存到该方法对应的栈帧中</strong> )。<br />
<img src="/assets/posts_jpg/Java/java-knowledge/无锁升级偏向锁.jpg"
alt="无锁升级偏向锁" /><br />
  当一个线程给对象上锁时，先判断Mark
Word中标志位，然后再判断是否为偏向锁。如果不是偏向锁，则通过CAS修改Mark
Word，将Mark
Word改为偏向锁状态且将线程id指向当前线程。如果对象已经是偏向锁了，则只需要判断Mark
Word中的线程id是否是当前线程，如果是则不需要CAS操作，直接获得锁。因为
<strong>偏向锁是不会释放的</strong>
，其他线程想给偏向锁状态对象上锁时，就通过 <strong>Epoch</strong>
位判断偏向锁是否能重新偏向，也就是上一个获得偏向锁的线程是否失效。<br />
<img src="/assets/posts_jpg/Java/java-knowledge/其他线程获得偏向锁.jpg"
alt="无锁升级偏向锁" /><br />
  偏向锁相当于
<strong>偏向第一个将对象无锁态升级为偏向锁态的线程</strong>
，当该线程死亡，或者不需要该锁，其他线程尝试获得锁时，会先重置为无锁，然后再升级为偏向锁，这个过程的消耗导致
<strong>偏向锁效率不一定比轻量级锁高</strong>
。可以通过UseBiasedLocking参数来开启关闭偏向锁，如果关闭，则对象直接从无锁状态升级到轻量级锁。</p></li>
<li><h3 id="轻量级锁">轻量级锁</h3>
<p>  当偏向锁有多个线程竞争时，偏向锁会撤销，升级成轻量级锁。锁对象为轻量级状态时，Mark
Word保存的数据是指向 <strong>Lock Record锁记录</strong>
的指针。线程打算给轻量级锁对象上锁时，会先在栈的栈帧中创建Lock
Record空间，然后把该锁的Mark
Word复制到该空间中，然后通过CAS竞争将指针指向Lock Record。<br />
<img src="/assets/posts_jpg/Java/java-knowledge/获取轻量级锁.jpg"
alt="获取轻量级锁" /><br />
  轻量级锁的特点是线程不会阻塞，而是自旋等待。当某个线程自旋次数超过一定次数时，轻量级锁会升级成重量级锁。可以通过参数PreBlockSpin设置，默认10次。</p></li>
<li><h3 id="重量级锁">重量级锁</h3>
<p>  当锁对象为重量级锁时，Mark
Word保存的是，指向monitor对象的指针。monitor由C++实现。每一个重量级锁对象和一个monitor对象关联。monitor中有个等待队列，该队列保存竞争该锁对象的线程。重量级锁状态涉及到操作系统来实现阻塞线程。<br />
<img src="/assets/posts_jpg/Java/java-knowledge/获取重量级锁.jpg"
alt="获取重量级锁" /><br />
  monitor对象由c++实现，内部属性 <strong>Owner</strong>
保存获得锁对象的线程。 <strong>EntryList</strong>
用来保存竞争锁失败的等待线程。<strong>WaitList</strong>
保存等待唤醒的线程。当 <strong>锁对象调用wait()方法</strong>
后，会将当前 <strong>owner线程阻塞</strong>
并加入到WaitList中等待notify()，唤醒后WaitList中的线程会加入到EntryList中。<strong>recursions</strong>
记录线程上锁次数，每重入一次recursions + 1，每释放一次recursions -
1。</p></li>
</ul></li>
<li><h2 id="lock类">Lock类</h2>
<p><a
href="/Java/java基础/juc-AQS/#jump_aqs"><font color="007FFF">java的AQS类</font></a></p></li>
</ul></li>
</ul>
<!-- - # java中synchornized和Lock的使用场景  
  - ## synchronized  
&ensp;&ensp;1.自动释放锁；2.不可中断；3.非公平；4.jdk1.6之后，synchronized优化，性能得到提升。一般优先使用synchronized。  

  - ## Lock实现类  
&ensp;&ensp;1.主动释放锁；2.可中断；3.可公平。4.读锁增加读操作并发效率。  

  - ## 使用场景  
&ensp;&ensp;在线程数量多，竞争激烈情况下，jdk1.6之后的synchronized执行效率，和Lock实现类，差距没有特别大,几乎差不多。  
&ensp;&ensp;在线程数量少时，synchronzied效率比Lock实现类高。 -->
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>java中的集合</title>
    <url>/Java/java%E5%9F%BA%E7%A1%80/java-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<ul>
<li><h1 id="hashmap">HashMap</h1>
<ul>
<li><h2 id="红黑树">红黑树</h2>
<p><a
href="/算法和数据结构/数据结构-树/#jump_rbt"><font color="007FFF">红黑树</font></a></p></li>
<li><h2 id="treeifybin">treeifyBin</h2>
<p>  当数组中的某一条 Node 单向链上的节点数大于等于
<strong>TREEIFY_THRESHOLD</strong> 时，会执行 treeifyBin() 方法。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e<span class="token punctuation">;</span>
    <span class="token comment">// 扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MIN_TREEIFY_CAPACITY</span><span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hd <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> tl <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 将 Node单向链 替换成 TreeNode双向链</span>
        <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> <span class="token function">replacementTreeNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                hd <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">;</span>
                tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            tl <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 将 Node单向链头节点 替换成 TreeNode双向链头节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hd<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            hd<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  如果数组长度，大于等于 <strong>MIN_TREEIFY_CAPACITY</strong>
，就将该单向链，优化成红黑树。首先先将Node单向链，转换为TreeNode双向链，再转为红黑树结构。</p></li>
<li><h2 id="treeify">treeify</h2>
<p>  TreeNode类中的treeify方法，将TreeNode双向链转为树结构。TreeNode类中，有
next，prev 字段，来保存双向链结构。有 parent，left，right
字段，保存红黑树结构。双向链结构节点顺序 和 红黑树结构节点顺序 之间
<strong>互不影响</strong> 。在 resize() 扩容时，TreeNode节点是通过
<strong>双向链结构</strong> ，更新节点的位置。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeify</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token comment">// 从当前节点，也就是调用该方法的节点开始到链末，转为树结构</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> x <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> next<span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> x <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        next <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        x<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果还没有根节点，当前节点设为根节点</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            x<span class="token punctuation">.</span>parent <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            x<span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            root <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">K</span> k <span class="token operator">=</span> x<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
            <span class="token keyword">int</span> h <span class="token operator">=</span> x<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> kc <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token comment">// 将当前链节点插入到树中</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// dir表示节点左右 ；ph表示当前树节点的hash</span>
                <span class="token keyword">int</span> dir<span class="token punctuation">,</span> ph<span class="token punctuation">;</span>
                <span class="token class-name">K</span> pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">></span> h<span class="token punctuation">)</span>
                    <span class="token comment">// 插入的链节点 往该树节点左侧插入</span>
                    dir <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ph <span class="token operator">&lt;</span> h<span class="token punctuation">)</span>
                    <span class="token comment">// 右侧</span>
                    dir <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                <span class="token comment">/**
                如果key的hash相等的情况下：
                1.当前链节点的key实现了comparable接口，且compare后依然相等即dir为0。
                2.没有实现comparable接口
                通过tieBreakOrder方法比较。  
                */</span>    
                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>kc <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                        <span class="token punctuation">(</span>kc <span class="token operator">=</span> <span class="token function">comparableClassFor</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span>
                        <span class="token punctuation">(</span>dir <span class="token operator">=</span> <span class="token function">compareComparables</span><span class="token punctuation">(</span>kc<span class="token punctuation">,</span> k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    dir <span class="token operator">=</span> <span class="token function">tieBreakOrder</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> xp <span class="token operator">=</span> p<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>left <span class="token operator">:</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    x<span class="token punctuation">.</span>parent <span class="token operator">=</span> xp<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                        xp<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>
                    <span class="token keyword">else</span>
                        xp<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>
                    <span class="token comment">// 树的重新平衡    </span>
                    root <span class="token operator">=</span> <span class="token function">balanceInsertion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">/**
    当链节点全部添加到树中后：
    对于TreeNode节点来说，即存在prev，next所指的双向链结构，也存在parent，left，right所指的红黑树结构。
    经过多次重新平衡，数组中的头节点，不一定是root节点。将root节点设为数组中头节点，并在双向链结构中，将头节点和root节点位置对调。
    */</span>
    <span class="token function">moveRootToFront</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  在当前连接点插入到树后，红黑树需要重新平衡。多次平衡后，树的root节点，不一定是链的头节点。因此需要把数组中的对应位置上的对象，改为root节点作为遍历入口。因为树结构遍历入口是root节点，因此数组中的对应位置上保存的是root节点，但是在扩容时，TreeNode通过双向链结构遍历节点，因此需要将root节点和原链结构头节点位置对换，保证root节点也是
<strong>双向链头节点</strong>。</p></li>
<li><h2 id="哈希冲突和解决方法">哈希冲突和解决方法</h2>
<ul>
<li>开放定址法</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立公共溢出区</li>
</ul></li>
<li><h2 id="时间复杂度和链转树的阈值">时间复杂度和链转树的阈值</h2>
<p>  在hashMap中，put，get等方法，通过key值做hash，可以O(1)得到数组中的位置。对于链来说，找到对应的元素时间复杂度O(n)。对于红黑树来说，找到对应元素的时间复杂度为O(logn)。<br />
  但是，哈希表存放数据是符合 <strong>泊松分布</strong> (
随机事件发生多少次的概率分布
)。λ是事件平均发生率。泊松分布概率计算公式：<br />
<span class="math display">\[P(X = n) =
\frac{\lambda^{n}e^{-\lambda}}{n!}\]</span>
  以hashMap举例：put一个元素，key的一次hash冲突，相当于一个独立事件。n次hash冲突相当于链的长度。而put一个元素，发生多次hash冲突的概率相当的低。因此，从概率上说hashMap的put、get等方法的时间复杂度可以当作
<strong>O(1)</strong> 。<br />
  换一种角度来说，链转树的阈值设为8，也是符合泊松分布。在默认的
<strong>LOAD_FACTOR = 0.75f</strong> 的情况下，概率计算公式中
<strong>λ的值约为0.5</strong> 。在这个情况下，一次put操作，发生
<strong>冲突次数大于8的概率几乎为0</strong>
。因此，如果阈值设为大于8的数，几乎不会到达这个值。也就是说几乎不会发生链转树。总的来说，hashMap中的LOAD_FACTOR，影响泊松分布函数中的λ，从而影响链转树的阈值。</p></li>
<li><h2
id="扩容的角度对二进制位移的总结">扩容的角度对二进制位移的总结</h2>
<p>  以HashMap扩容时举例，当数组size为16时，扩容后size为32。原数组上的节点，扩容后有两种结果，原坐标，或者原坐标+原size的新坐标，也就是扩容后新增的位，结果是0或者1的区别。从这个例子中，来总结下，二进制的位移的部分知识点，是在LeetCode做题中忽视过的。4位二进制数表示范围是
0~15 共16个数，左移1位，5位二进制数表示范围是 0 ~ 31
共32个数。左移1位，就相当于乘以10，二进制中的10转为十进制就是2。对于5位二进制的32个数中，已经包含了全部的4位二进制的16个数。那么5位和4位相比，高位新增的一位，也就只有两种结果：0或者1。为0时，值的大小和原4位保持一致。为1时，值的大小是对应的原4位大小
+ <span class="math inline">\({2^4}\)</span> 。换个角度说，就相当于在
原4位能表示的所有二进制数前面补0，这部分的数值不变，而多增加的16个数，就是原4位的所有二进制数前面补1。如：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token number">2</span>位数能表示的所有结果： <span class="token number">00</span> <span class="token number">01</span> <span class="token number">10</span> <span class="token number">11</span>
<span class="token number">3</span>位数能表示的所有结果，原<span class="token number">2</span>位前补<span class="token number">0</span>： <span class="token number">000</span> <span class="token number">001</span> <span class="token number">010</span> <span class="token number">011</span>
                     原<span class="token number">2</span>位前补<span class="token number">1</span>： <span class="token number">100</span> <span class="token number">101</span> <span class="token number">110</span> <span class="token number">111</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ul></li>
<li><h1 id="linkedhashmap">LinkedHashMap</h1>
<p>LinkedHashMap.Entry类中通过 before 和 after 字段，记录节点 添加顺序
  afterNode...</p></li>
<li><h1 id="arraylist">ArrayList</h1></li>
<li><h1 id="linkedlist">LinkedList</h1></li>
<li><h1 id="priorityqueue">PriorityQueue</h1></li>
<li><h1 id="集合框架中的modcount">集合框架中的modCount</h1>
<p>  对集合对象的增，删，改，都会增加啊modCount值，该值用于记录集合对象修改次数。只有在迭代器中有使用，当迭代器遍历元素时，如果生成迭代器时的modCount
和
现在的不相等，就表示有其他线程，对集合对象做了写操作。而迭代器在遍历过程中，如果也需要进行写操作，且modCount不一致，就会直接抛出异常。这个也就是
Fail-Fast机制。<br />
  modCount字段，和线程安全相关，对于juc包中的集合，不需要该字段。</p></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的线程池</title>
    <url>/Java/java%E5%9F%BA%E7%A1%80/juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<ul>
<li><h1 id="线程池的优点">线程池的优点</h1>
<ul>
<li>线程可重用，减少资源消耗。<br />
</li>
<li>提高线程管理性。<br />
</li>
<li>线程 和 任务 解耦。</li>
</ul>
<p>  线程池相当于两个部分组成,任务管理 和
线程管理。任务管理相当于生产者，线程管理相当于消费者，非核心线程如果没申请到任务，会被回收。<br />
  任务集合 由接口BlockingQueue实现类来实现，线程集合
通过HashSet&lt;Worker&gt;来实现。任务集合也即阻塞队列的具体结构，规则等由BlockingQueue子类实现。<br />
  线程池实现类ThreadPoolExecutor，构造方法接收参数
<strong>corePoolSize</strong>
表示核心线程数，核心线程即使没有任务执行也不会回收，<strong>maximumPoolSize</strong>
表示最大允许线程数，BlockingQueue实例对象 <strong>workQueue</strong>
表示阻塞队列，BlockingQueue是接口，阻塞队列的具体规则,内部结构,由子类实现。AtomicInteger型字段
<strong>ctl</strong> 表示 线程池状态 和 线程数量，ctl
高3位表示<em>状态</em>，低29位表示<em>线程数</em>。</p></li>
<li><h1 id="线程池的5种运行状态为">线程池的5种运行状态为</h1>
<ul>
<li>Running 运行 ：运行时可接收任务，工作线程执行任务。<br />
</li>
<li>Shutdown 关闭 ：停止接收任务，工作线程执行任务，空闲线程中断。<br />
</li>
<li>Stop 停止 ：停止接收任务，空闲的和工作中的线程都中断。<br />
</li>
<li>Tidying 清空 ：线程数清0。<br />
</li>
<li>Terminated 结束 ：结束。</li>
</ul>
<p>  方法execute()相当于线程池入口，execute()接收一个Runnable对象，相当于提交任务。
  根据线程池的线程数和阻塞队列状态，任务提交时可分为:</p>
<ul>
<li>poolSize &lt; corePoolSize，则直接创建线程执行该任务。<br />
</li>
<li>poolSize &gt;= corePoolSize 且
阻塞队列没有满，则将任务添加到阻塞队列中，通过BlokingQueue类的offer()方法添加提交。<br />
</li>
<li>阻塞队列满了，且 poolSize &lt;
maximumPoolSize，则创建线程执行任务。<br />
</li>
<li>poolSize &gt;= maximumPoolSize，拒绝任务。</li>
</ul></li>
<li><h1 id="内部类worker">内部类Worker</h1>
<p>  上面提到的创建线程执行任务， 创建的是
内部类Worker的对象。内部类Worker继承AbstractQueueSynchronizer类，实现了Runnable接口，其本身既是一个不可重入锁，也是线程Thread要执行的target。Worker类的
lock()方法直接调用AQS类的acquire()方法，tryLock()方法调用自己重写的tryAcquire()方法，tryAcquire()方法就只有通过CAS将AQS的字段state变为1和修改成功将锁的owner设成自己的线程，没有ReentrantLock中的可重入判断，来实现
<strong>非可重入锁</strong> 。<br />
  Worker类 有个Thread对象,创建时相当于new
Thread(Worker.this)，启动时来执行Worker重写的run方法，因此Worker相当于一个封装好的线程池中执行任务的线程。Worker构造方法接收Runnable对象作为firstTask，也即线程执行的第一个任务，该任务也就是线程池入口execute()方法传进来的Runnable对象。work线程进入到一个while循环中，当线程的firstTask为空，且线程调用getTask()方法没获取的任务时，结束循环。其中getTask()方法内，通过
<strong>自旋</strong> 和
<strong>BlockQueue实现类中方法里的Lock锁</strong>
来保证提取任务的线程安全。通过这个循环保证工作线程一直在执行任务，一个任务完成就从阻塞队列中获得任务去执行。当work线程获得了任务，在执行前会先通过worker.lock()上锁，任务完成时再unlock(),这里
<strong>通过上锁来辨别线程状态</strong>
。当worker上锁时，就表示在执行任务，反之则空闲。当线程池调用shutdown()方法进入SHUTDOWN状态时，会执行interruptIdleWorkers()方法来中断空闲线程，判断是否为空闲线程就是通过tryLock()方法，因此这里不能使用可重入锁。<br />
  AQS上锁也是通过CAS修改int型字段
state来实现的，state为0就没有上锁。非可重入锁的state只有0或者1，因此通过
worker是否上锁来辨别是否空闲，也相当于 boolean
来判断线程是否空闲。</p></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>juc</tag>
        <tag>AQS</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>juc包中的集合</title>
    <url>/Java/java%E5%9F%BA%E7%A1%80/juc-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<ul>
<li><h1 id="concurrenthashmap">ConcurrentHashMap</h1>
<p>  ConcurrentHashMap中的put方法，通过for死循环自旋 和 CAS添加数据 和
synchronized同步锁，保证数据不丢失。CurrentHashMap的扩容和HashMap一样的增加数组长度和节点位置更新。扩容的时机也和HashMap差不多，链表转红黑树时，或者添加元素后判断需要扩容。addCount方法实现添加元素后，元素数量增加。扩容时的节点转移通过transfer方法实现。</p>
<ul>
<li><h2 id="addcount方法实现原理">addCount方法实现原理</h2>
<p>  ConcurrentHashMap对容量的增加，实现原理和LongAdder类似。如果CAS修改容量大小失败，不进行自旋，将要增加的值x，保存在数组中。容量的大小，就是数组中所有值以及baseCount的和。</p></li>
<li><h2
id="扩容及节点位置转移transfer方法">扩容及节点位置转移，transfer方法</h2>
<p>  ConcurrentHashMap在扩容时，对于单向链的迁移，使用的是创建一个新节点，新节点的保存的数据和旧节点的一致，并使用
<strong>头插法</strong> 插入到链中。<br />
  和HashMap不同的是，HashMap在put和resize时都是尾插法。ConcurrentHashMap在put时是尾插法，transfer时是头插法，且是创建新Node对象。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">,</span> stride<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">NCPU</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token constant">NCPU</span> <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token constant">MIN_TRANSFER_STRIDE</span><span class="token punctuation">)</span>
        stride <span class="token operator">=</span> <span class="token constant">MIN_TRANSFER_STRIDE</span><span class="token punctuation">;</span>
    <span class="token comment">/**
    nextTab为null，则当前线程是发起扩容的线程，创建长度为2倍的数组。  
    nextTab不为null，则当前线程是辅助扩容的线程。
    */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
            <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token punctuation">></span></span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            nextTab <span class="token operator">=</span> nt<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     
            sizeCtl <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        nextTable <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>
        <span class="token comment">/**
        需要迁移的长度，也就是旧数组的长度。
        从数组后往前迁移
        */</span>
        transferIndex <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> nextn <span class="token operator">=</span> nextTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// fwd节点用来标识迁移完成，也就是旧数组哪些位置上的节点迁移完成</span>
    <span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> fwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> finishing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bound <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> fh<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>advance<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> nextIndex<span class="token punctuation">,</span> nextBound<span class="token punctuation">;</span>
            <span class="token comment">// 从后往前遍历旧坐标中要迁移的节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>i <span class="token operator">>=</span> bound <span class="token operator">||</span> finishing<span class="token punctuation">)</span>
                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment">// transferIndex值小于等于0 迁移完成    </span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nextIndex <span class="token operator">=</span> transferIndex<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token comment">/**  
            当前线程迁移哪个范围上的节点，从位置bound 到 i 上的节点
            通过CAS将nextBound赋值给transferIndex
            如果线程处理完迁移任务，但整个集合还没全部完成，
            也就是i&lt;bound但transferIndex大于0，重新获得新的范围
            */</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span>compareAndSwapInt
                    <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">TRANSFERINDEX</span><span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span>
                    nextBound <span class="token operator">=</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">></span> stride <span class="token operator">?</span>
                                nextIndex <span class="token operator">-</span> stride <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                bound <span class="token operator">=</span> nextBound<span class="token punctuation">;</span>
                i <span class="token operator">=</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 旧数组中节点迁移全部完成</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> n <span class="token operator">||</span> i <span class="token operator">+</span> n <span class="token operator">>=</span> nextn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sc<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>finishing<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                nextTable <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                <span class="token comment">// 使用新数组</span>
                table <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>
                sizeCtl <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">,</span> sc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token constant">RESIZE_STAMP_SHIFT</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                finishing <span class="token operator">=</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                i <span class="token operator">=</span> n<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">// 如果旧数组该位置为null，则没有要转移的节点，赋值fwd节点表示该位置转移完成</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            advance <span class="token operator">=</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果旧数组该位置节点已经是fwd节点了，则跳过</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">MOVED</span><span class="token punctuation">)</span>
            advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment">// 节点位置转移    </span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 旧数组 i 位置上的 头节点上锁 防止其他线程插入新节点</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> ln<span class="token punctuation">,</span> hn<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token keyword">int</span> runBit <span class="token operator">=</span> fh <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>
                        <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> lastRun <span class="token operator">=</span> f<span class="token punctuation">;</span>
                        <span class="token comment">/**
                        对于一个节点，迁移时有两种位置，旧位置 i，和新位置 i+n
                        runBit的0或1 表示 lastRun在旧位置还是新位置
                        lastRun 表示 从该节点起到最后一个节点，都是相同的runBit
                        可以直接把lastRun迁移，遍历节点就不需要再遍历lastRun和之后的节点
                        */</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            <span class="token keyword">int</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> runBit<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                runBit <span class="token operator">=</span> b<span class="token punctuation">;</span>
                                lastRun <span class="token operator">=</span> p<span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>
                        <span class="token punctuation">&#125;</span>
                        <span class="token comment">// 表示lastRun及其之后的节点 都在旧位置，直接把lastRun设为旧位置链的头节点</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>runBit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            ln <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>
                            hn <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                            hn <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>
                            ln <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                        <span class="token comment">/**
                        ConcurrentHshMap迁移节点使用 头插法  
                        遍历节点只需遍历 头节点 到 lastRun之前的节点
                        lastRun和之后的节点已经迁移完
                        */</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> f<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            <span class="token keyword">int</span> ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span> <span class="token class-name">K</span> pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span> <span class="token class-name">V</span> pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                            <span class="token comment">// 直接new和原节点数值一样的新节点 头插法插入</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                                ln <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                hn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                        <span class="token comment">// 在新数组的 i 位置上 赋值 ln节点</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment">// 旧数组的 i 位置上的节点替换为fwd，表示该位置迁移完成</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>f<span class="token punctuation">;</span>
                        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> lo <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> hi <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                        <span class="token keyword">int</span> lc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> hc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> e <span class="token operator">=</span> t<span class="token punctuation">.</span>first<span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            <span class="token keyword">int</span> h <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">;</span>
                            <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span>
                                <span class="token punctuation">(</span>h<span class="token punctuation">,</span> e<span class="token punctuation">.</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span>val<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> loTail<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                    lo <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                <span class="token keyword">else</span>
                                    loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                loTail <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                <span class="token operator">++</span>lc<span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>
                            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>prev <span class="token operator">=</span> hiTail<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
                                    hi <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                <span class="token keyword">else</span>
                                    hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                hiTail <span class="token operator">=</span> p<span class="token punctuation">;</span>
                                <span class="token operator">++</span>hc<span class="token punctuation">;</span>
                            <span class="token punctuation">&#125;</span>
                        <span class="token punctuation">&#125;</span>
                        ln <span class="token operator">=</span> <span class="token punctuation">(</span>lc <span class="token operator">&lt;=</span> <span class="token constant">UNTREEIFY_THRESHOLD</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span>
                            <span class="token punctuation">(</span>hc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>lo<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>
                        hn <span class="token operator">=</span> <span class="token punctuation">(</span>hc <span class="token operator">&lt;=</span> <span class="token constant">UNTREEIFY_THRESHOLD</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">untreeify</span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span>
                            <span class="token punctuation">(</span>lc <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TreeBin</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>hi<span class="token punctuation">)</span> <span class="token operator">:</span> t<span class="token punctuation">;</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><h2
id="辅助扩容helptransfer方法和transfer方法">辅助扩容，helpTransfer方法和transfer方法</h2>
<p>  当某一个线程在执行transfer方法扩容时，另一个线程在put时，如果此时数组上的该位置节点为fwd节点，就表示此时正在扩容，则通过helpTransfer方法协助扩容。<br />
  如果不是fwd节点，在插入新节点时会尝试给该位置头节点上锁，而扩容时也会上锁，因此其他线程的put操作，只有在该位置还没有开始迁移时才能完成。如果该位置已经开始迁移，其他线程对该位置的put操作，会等待锁释放。但是迁移完成后该位置的节点变为fwd节点，因此其他线程还是会执行helpTransfer方法。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span> f<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>
    <span class="token comment">// 通过fwd节点获得扩容时的新数组nextTable</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">ForwardingNode</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>nextTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ForwardingNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">></span></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span>nextTable<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/**
        sizeCtl 高16位的值 表示 容量
        sizeCtl 低16位的值 表示 进行扩容的线程数；如果低16位值为M，就有M-1个线程在扩容
        */</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> nextTable <span class="token operator">&amp;&amp;</span> table <span class="token operator">==</span> tab <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">>>></span> <span class="token constant">RESIZE_STAMP_SHIFT</span><span class="token punctuation">)</span> <span class="token operator">!=</span> rs <span class="token operator">||</span> sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span>
                sc <span class="token operator">==</span> rs <span class="token operator">+</span> <span class="token constant">MAX_RESIZERS</span> <span class="token operator">||</span> transferIndex <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">U</span><span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">SIZECTL</span><span class="token punctuation">,</span> sc<span class="token punctuation">,</span> sc <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token comment">// 依旧是通过transfer迁移节点</span>
                <span class="token function">transfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> nextTab<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> table<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  helptransfer方法调用transfer方法来迁移节点。transfer方法只有发起扩容的线程会在nextTab传null，表示要新建数组。其他线程可直接通过fwd节点获得新数组，不要再创新数组。</p></li>
</ul></li>
<li><h1 id="copyonwritearraylist">CopyOnWriteArrayList</h1></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>juc</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习笔记</title>
    <url>/Java/java%E5%9F%BA%E7%A1%80/jvm-A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li><h1 id="jvm的垃圾回收知识点">JVM的垃圾回收知识点</h1></li>
<li><h3 id="判断对象是否回收的方法">判断对象是否回收的方法 ：</h3>
<ul>
<li><h4 id="引用计数法">引用计数法 ：</h4>
<p>  给对象添加一个引用计数器，当对象每次被引用时 +1，失去一次引用
-1，根据计数器判定对象是否还有在使用。缺点是只靠引用计数法，无法解决对象相互引用的问题。如：引用
oA 指向 对象A，引用 oB 指向 对象B， oA 中内部字段指向 对象B，oB
中的内部字段指向 对象A，这时 对象A和对象B之间相互引用，就算通过 oA =
null，oB = null取消引用，对象A 和 对象B
的计数器也不为0。因此java虚拟机中不通过引用计数法判断对象是否存活。</p></li>
<li><h4 id="可达性分析法">可达性分析法 ：</h4>
<p>  将符合条件的对象GC
Roots作为起点集合，从这些对象开始，通过引用关系向下搜索，搜索的路径也就是
<strong>引用链</strong> ，当对象和GC
Roots间没有引用链时，也就是该对象不可达，则该对象已不再可用。<br />
  能够作为GC Root的对象有：<br />
  1. 虚拟机栈中引用所指对象。<br />
  2. 方法区中静态引用所指对象。<br />
  3. 方法区中常量引用所指对象。<br />
  4. 本地方法栈中引用所指对象。<br />
  5. 同步锁(synchronized)获得的对象。<br />
  6. 运行中的线程对象。</p></li>
</ul></li>
</ul>
<p>  可达性分析法不是直接把不可达对象作为垃圾回收，会通过两次标记来让部分对象自救存活。第一次可达性判定后，所有不可达的对象做上标记这是
<strong>第一次标记</strong> ，然后进行筛选，将所有标记对象分为
执行finalize()方法的 和 不执行finalize()方法的，筛选条件是 对象是否
<strong>重写了finalize()方法</strong> 或
<strong>对象是否已经被虚拟机执行过一次finalize()方法</strong> 。如果
<strong>对象重写了方法 且 还没有被执行过finalize()方法</strong> 则视为
执行方法的对象，否则为 不执行方法对象。如果
对象是不执行方法的，则依旧是等待回收的垃圾对象，如果
对象是执行方法的，则将该对象加入到F-Queue队列中，虚拟机开启一个Finalizer线程来执行队列中对象的finalize()方法，如果队列中的某个对象因为执行finalize()方法后，使得GC
Roots可达，则取消标记不用被回收，这就是 <strong>第二次标记</strong>
，相当于 finalize()方法是
垃圾对象的一次自救机会但也只有一次。任何一个对象的finalize()方法都只会被
<strong>系统自动调用一次</strong> 。</p>
<ul>
<li><h3 id="java中的引用">java中的引用 ：</h3>
  jdk1.2后将引用这个概念进行了细分，由强到弱为:
<ul>
<li><h4 id="强引用">强引用</h4>
  指的就是最常使用的引用，即Object obj = new
Object(),obj就是强引用。只要强引用还指向对象，也就是对象可达，该对象是不会被垃圾回收的。<br />
</li>
<li><h4 id="软引用">软引用</h4>
  通过SoftReference类实现的引用，当内存不够发生溢出异常前，会将
<strong>只有</strong>
软引用所指对象列入回收范围中进行第二次回收。也就是说，如果GC后内存还是不够，那么即使对象可达，只被软引用指向的对象，还是会被回收。使用方法
SoftReference soft = new SoftReference(obj)。<br />
</li>
<li><h4 id="弱引用">弱引用</h4>
  通过WeakReference类实现的引用，生存到下一次垃圾回收前。当垃圾收集器开始执行时，无论内存是否够，<strong>只有</strong>
弱引用所指对象会被回收。使用方法 WeakReference weak = new
WeakReference(obj)。<br />
</li>
<li><h4 id="虚引用">虚引用</h4>
  通过PhantomReference类实现的引用，虚引用唯一作用是当被虚引用关联的对象被回收时，获得系统通知，相当于跟踪GC。
<strong>java8及之前 虚引用 ( 本身就是PhantomReference对象 )
被回收后，虚引用所指对象才会回收，java9及之后虚引用不会对对象造成影响，在虚引用所指对象回收后，虚引用会有
引用队列 处理</strong> 。使用方法 PhantomReference phantom = new
PhantomReference(obj,referenceQueue)，垃圾回收后虚引用会被添加到引用队列中。</li>
</ul></li>
<li><h3 id="垃圾收集算法">垃圾收集算法</h3>
<ul>
<li><h4 id="分代收集理论">分代收集理论</h4>
<p>  首先这个不算算法，而是一种分区域处理的理论，3种垃圾收集算法：标记-清除，标记-复制，标记-整理，就是对这个理论的具体思路设计。多数垃圾收集器都遵循分代收集理论，将java堆分区域处理。
<strong>java虚拟机中，分代收集理论的具体表现，一般都有将java堆分为
新生代和老年代</strong> 。</p></li>
<li><h4 id="标记-清除算法">标记-清除算法</h4>
<p>  标记-清除就是两个阶段，第一阶段给对象是将存活对象做标记，清除就是将没有标记的垃圾对象回收。这个方法有两个问题：1.标记和清除的效率都受
堆中需要清除的对象数量 影响 ；2.该算法回收内存空间后，
<strong>会造成碎片化空间</strong>
，空间资源的浪费，碎片太多可能导致生成大对象时没有足够的空间，而提前发生垃圾回收。</p></li>
<li><h4 id="标记-复制算法">标记-复制算法</h4>
<p>  简称复制算法，最开始提出的是半区分代，将内存分为等大小两块，使用时只使用其中一块，应一块作为保留空间。垃圾回收时，对使用的那一块内存中的垃圾对象做标记，然后将存活对象按顺序分配保留空间的内存中，然后清除掉使用中内存的
<strong>所有对象</strong>
，这时两块内存区域也就互换，清除完对象的那一块成为新的保留空间，前保留空间也成了新使用中内存。复制算法的优点是不会有碎片化空间，缺点是
<strong>只有原本的一半空间可以使用</strong> 。<br />
  为了解决一半空间浪费问题，且针对 <strong>新生代</strong>
大部分对象朝生夕灭，将复制算法进行优化，称为
<strong>Appel式回收</strong>
。Appel式将新生代分为了三块，1块eden区，2块survivor区。默认1 eden : 1
survivor = 8 : 1,每次分配内存只使用eden区 +
一个survivor区，另一个survivor用来保存存活的对象。当发生垃圾收集时，将eden区和survior区的存活对象复制到另一个survivor区，然后清空eden
+ survivor区的所有对象。Appel式回收将使用空间从 50% 增加到
90%。当复制时survivor区内存大小不足够存放时，会依赖其他内存空间进行分配担保(就老年代，即对象直接进入老年代)。
<strong>标记-复制法在对象成活率较高的区域要进行大量复制</strong>
，因此该算法不能用在老年代。</p></li>
<li><h4 id="标记-整理算法">标记-整理算法</h4>
<p>  针对老年代的算法。整体流程和标记-清除算法差不多，但标记完的后续步骤不是直接清除对象，是把存活对象向内存中一段移动，未存活的清除掉。<br />
  标记-清除和标记-整理之间的差距在于最后的整理，是否对对象进行整理都存在弊端。不对对象进行整理，内存分配时会更麻烦，速度快，但是会产生碎片化空间。对对象进行整理，速度慢，移动对象操作消耗大，如果
<strong>不是ZGC或者Shenandoah垃圾收集器</strong> ，这个
<strong>移动对象的过程会全程暂停用户线程，也就是stop the world</strong>
，但不会产生碎片化空间。</p></li>
</ul></li>
<li><h3 id="垃圾收集器">垃圾收集器</h3>
  垃圾回收算法相当于回收方法，垃圾收集器相当于回收执行者。作用于新生代的
serial，parallel，parNew。作用于老年代的 serial Old，parallel
Old，CMS，及比较特殊的G1。
<ul>
<li><h4 id="serial-收集器-和-serial-old-收集器">serial 收集器 和 serial
old 收集器</h4>
<p>  单线程收集器，只有一条垃圾收集线程。serial收集器作用于新生代，使用
<strong>标记-复制算法</strong> 。serial old收集器作用于老年代，使用
<strong>标记-整理算法</strong> 。缺点是垃圾收集时会stop the
world，暂停其他所用工作线程，直到收集结束。serial收集器是客户端默认新生代收集器，serial
old收集器的主要作用也是客户端下的老年代收集器。</p></li>
<li><h4 id="parnew-收集器">parNew 收集器</h4>
<p>  serial收集器的多线程版本，有多条垃圾回收线程，垃圾收集时同样也会stop
the
world。作用于新生代，几乎和serial收集器没有太多差别。java9开始，只支持和老年代收集器CMS搭配使用，几乎退出历史舞台。</p></li>
<li><h4 id="parallel-收集器-和-parallel-old-收集器">parallel 收集器 和
parallel old 收集器</h4>
<p>  多线程处理器，有多条垃圾收集线程，垃圾收集时同样也会stop the
world。parallel收集器作用于新生代，使用标记整理算法。几乎和parNew收集器差不多，唯一的特点是对
<strong>吞吐量</strong> 的关注。 <strong>吞吐量 = 运行用户代码时间 / (
运行用户代码时间 + 运行垃圾收集时间 )</strong> ，相当于parNew收集器的
关注吞吐量版本。有两个参数用来控制吞吐量，直接设置吞吐量的
<strong>GCTimeRatio</strong> 和 设置最大垃圾收集停顿时间的
<strong>MaxGCPauseMillis</strong>
,垃圾收集停顿时间就是垃圾回收线程执行时，用户线程停顿时间。parallel old
就是 parallel的老年代版本，使用标记-整理算法，其他没什么差别。</p></li>
<li><h4 id="cms-收集器">CMS 收集器</h4>
<p>  concurrent-mark-sweap
收集器，作用于老年代，使用标记-清除算法。整个垃圾收集过程分为4个部分。1.初始标记，2.并发标记，3.重新标记，4.并发清除。其中
初始标记 和 重新标记 会stop the world。初始标记阶段就是标记 GC Roots
可直接关联对象，耗时短，暂停用户线程。并发标记阶段，从GC Roots
可直接关联对象出发遍历整个引用链，耗时长，但是和用户线程并发执行。重新标记阶段为了解决并发标记阶段用户线程运行导致的变化，多条线程处理，耗时比并发标记短，暂停用户线程。并发清理阶段，清理标记的对象。由于使用的标记-清除算法，因此
<strong>会产生碎片化空间</strong>
且并发标记和并发清除阶段和用户线程并发执行，所以
<strong>处理器资源占用较大</strong>
。在并发清除阶段，只能清除之前标记的对象，如果在这个阶段，用户线程的行为产生的垃圾对象，只能下一次垃圾回收执行，这种对象也称为
<strong>浮动垃圾</strong> ，CMS收集器无法处理浮动垃圾。</p></li>
<li><h4 id="g1-收集器">G1 收集器</h4>
<p>  Garbage First
收集器。主要面向服务端，作用于新生代和老年代，面向堆内任何部分回收垃圾。G1收集器
将java堆内存分为若干 <strong>大小相等的独立区域Region</strong>
，每一个Region根据分配可以作为新生代Eden，Surviver区，和老年代空间，G1收集器中，还有专门用来存储大对象的Humongous区，对超过Region大小一半的对象视为大对象，如果大对象超过1个Region大小，就多个连续Humongous区存储，Region大小可以通过参数
<strong>G1HeapRegionSize设置</strong> ，范围在1MB~32MB。收集器可以
<strong>对不同的Region使用不同的垃圾回收策略</strong>
，新生代Region，Appel式标记-复制算法，老年代Region，标记-整理算法，大对象按老年代对象处理。G1收集器避免对全Region进行GC，对回收价值高的Region回收，
<strong>价值是回收后获得的空间和回收所需的时间</strong>
。G1收集器有个优先级列表，回收时根据最大收集停顿时间，收集停顿时间可以使用参数
<strong>MaxGCPauseMillis</strong> 设置，优先回收高价值Region。<br />
  G1收集器运行过程的4个步骤：<br />
  1.初始标记：只标记GC Roots直达对象。stop the world，单线程。<br />
  2.并发标记：对堆中对象进行可达性判断，耗时长，和用户线程并发，并发阶段通过
<strong>原始快照算法SATB</strong>
，让用户线程和GC线程互不干扰。Region的一部分空间用于并发回收时的新对象分配，这个空间的新对象默认不在回收范围。
<strong>和CMS一样如果最终回收速度比分配速度慢，导致内存不够，还是会暂停用户线程</strong>
。<br />
  3.最终标记：处理并发阶段遗留的SATB，stop the world，多线程。<br />
  4.筛选回收：stop the
world，多线程处理，将旧Region中对象复制到新Region中，在清空旧Region。</p></li>
<li><h4 id="zgc-收集器">ZGC 收集器</h4></li>
</ul></li>
<li><h3 id="内存分配及回收策略">内存分配及回收策略</h3>
<ul>
<li><h4 id="对象优先分配eden区">对象优先分配eden区</h4>
<p>  当eden区没有足够空间时，发生minor
GC，对新生代回收垃圾。<strong>如果survivor区空间小于minor GC
存活对象，则该存活对象直接进入老年代</strong> 。</p></li>
<li><h4 id="大对象直接进入老年代">大对象直接进入老年代</h4>
<p>  为了避免提前触发GC，通过参数
<strong>PretenureSizeThreshold</strong> 设置进入大对象的界限。
<strong>该参数只有 serial 和 parNew 两个新生代收集器 有用</strong>
。</p></li>
<li><h4 id="长期存活对象进入老年代">长期存活对象进入老年代</h4>
<p>对象每经历一次minor GC，年龄+1，通过参数
<strong>MaxTenuringThreshold</strong> 设置进入老年代年龄界限 。</p></li>
<li><h4 id="动态判断对象进入老年代">动态判断对象进入老年代</h4>
<p>  如果survivor区中某个年龄的所有对象空间占用超过survivor区的一半，则大于或等于这个年龄的所有对象进入老年代。</p></li>
<li><h4 id="空间分配担保">空间分配担保</h4>
<p>  在minor GC
发生前，虚拟机先判断老年代可用空间是否能容纳当前新生代所有对象，如果可以，则认为这次minor
GC是安全的。如果不行，通过参数 <strong>HandlePromotionFailure</strong>
是否允许担保失败。如果允许，则判断老年代可用空间是否 大于
<strong>前几次升到老年代的对象的平均大小</strong>
，如果大于，则依旧执行minor GC。如果小于或者不允许，则直接进行 full
GC。因为新生代存活对象要进入到survivor区，如果survivor区容量不够，则对象直接进入老年代区，
<strong>相当于老年代的担保</strong> 。因此minor
GC时判断老年代大小，来判定minor GC 风险
如：如果不判定老年代大小，直接进行minor
GC，如果老年代空间不够，依旧要执行 full GC，minor GC + full GC
两次回收造成的停顿时间就更长，而风险判定也许可以减少一次minor
GC的停顿而直接进行 full GC。</p></li>
</ul></li>
<li><h1 id="jvm类加载器">JVM类加载器</h1>
<h3 id="类的生命周期">类的生命周期</h3>
  类的生命周期为：加载，链接，初始化，使用，卸载。其中 <strong>加载 到
初始化</strong> 的过程，就是类加载过程 。</li>
</ul>
<h3 id="类加载的过程">类加载的过程</h3>
<h4 id="加载-loading">  加载 Loading</h4>
<p>  通过类的全名，也就是包名+类名。读取该类的.class文件 并将
.class文件的二进制流在方法区中转化为该类的数据结构，且在堆中生成该类的class对象。
####   链接 Linking<br />
  链接分为三部，验证，准备，解析。</p>
<h4 id="验证-verify">    验证 Verify</h4>
<p>    验证.class文件的正确性。</p>
<h4 id="准备-prepare">    准备 Prepare</h4>
<p>    为类static变量分配内存，并给变量初始值(初始值不是初始化阶段的赋值)。如果static修饰的变量也
<strong>被final修饰</strong>
，那么初始值就是赋的值。准备阶段只对static修饰的类变量分配内存。Java8之后，类变量会随着class对象
<strong>存在堆</strong> 中。</p>
<h4 id="解析-resolve">    解析 Resolve</h4>
<p>    将常量池中的符号引用转为直接引用。在将.java文件编译成.class文件时，因为还没加载到内存中，并不知道所引用的
<strong>实际地址</strong> 。因此先用一个符号来表示，这就是
<strong>符号引用</strong> 。</p>
<h4 id="初始化-initialization">  初始化 Initialization</h4>
<p>    初始化阶段为static变量赋值，及执行static代码块。<strong>类的初始化
不是
生成类的实例对象</strong>。当要用该类但没初始化时，会先初始化。如果有多个线程去初始化同一个类，只有获得初始化锁的线程来初始化该类。使用ClassLoader类的loadClass方法加载一个类，不是对类的使用，因此不会触发初始化。</p>
<h3 id="类加载器分类">类加载器分类</h3>
<p>  从虚拟机角度看，类加载器分为两种：一种是
<strong>虚拟机自身一部分</strong> ，由c++实现的启动类加载器Bootstrap
ClassLoader。一种是虚拟机外部，由java实现的
<strong>继承抽象类ClassLoader</strong> 的类加载器。<br />
  java一直保持着三层类加载器的类加载结构，也就是双亲委派模型。</p>
<h3 id="双亲委派模型">双亲委派模型</h3>
<h4 id="启动类加载器-bootstrap-class-loader">  启动类加载器 Bootstrap
Class Loader</h4>
<p>  由c++实现的加载器，是虚拟机内部的一部分，不能被java程序调用。负责加载jre/lib目录下能够识别的类库，如rt.jar，tool.jar等，不符合的类库放在目录下也不会加载，通过
<strong>sun.boot.class.path</strong>
可以查看加载的类库。在java中，无法表达出c++实现的加载器，因此用ClassLoader为
<strong>null</strong>
，表示bootstrap类加载器。除了启动类加载器，每个类加载器都要有自己的父类。<strong>类加载器之间的父类关系不是继承上的父类</strong>。抽象类ClassLoader的字段parent，用来保存该类加载器的父类。
####   扩展类加载器 Extension Class Loader<br />
  在java中由ExtClassLoader类实现，URLClassLoader的子类，字段parent 为
null表示父类加载器为BootStrap加载器。加载jre/lib/ext目录中的类库，通过
<strong>Java.ext.dirs</strong>
查看加载的类库。允许用户将类库放到ext目录下扩展功能。 ####
  应用程序类加载器 Application Class Loader<br />
  在java中由AppClassLoader类是实现，同样也是URLClassLoader类子类，字段parent为ExtClassLoader对象，表示父类加载器为Extension加载器。ClassLoader类的getSystemClassLoader方法返回值就是AppClassLoader。加载
<strong>java.class.path</strong> 系统属性
所指定的类库，这其中包括项目本身。</p>
<h4 id="双亲委派模型工作过程">  双亲委派模型工作过程</h4>
<p>  一个类加载器接收到类加载请求，不会自己加载类，会要父类也即字段parent的类去加载。每一层都是这样，直到到达顶部BootStrap加载器。只有当父类加载器无法加载，就是加载范围中不包括该类，才会要自己的子加载器去加载。<br />
  该过程的就是通过抽象类ClassLoader的方法 <strong>loadClass()</strong>
实现的。loadClass()方法内部会进行 if
判断，如果parent字段不为null，则调用父类的loadClass()方法。如果为null，就通过findBootStrapClassOrNull()方法委托BootStrap加载器。如果父类加载器无法加载，则会抛出ClassNotFoundException异常，这个时候会调用自己的
<strong>findClass()</strong> 方法。<br />
  findClass()过程内部会将包名+类名，转换为路径+.class后缀。如：a.b.Test类，转为a/b/Test.class。<br />
  每个加载器都会对自己加载过的类 <strong>缓存</strong>
。在loadClass()时，先通过 <strong>findedLoadClass()</strong>
方法检查是否已加载。如果已加载则返回该类class对象。没有才执行后面的步骤。而
<strong>热加载</strong>
不通过重启项目，达到功能上的更新，就需要解决类加载的缓存。</p>
<h3 id="破坏双亲委派模型">破坏双亲委派模型</h3>
<p>  上面提到了双亲委派是由 loadClass()
方法中的判断流程实现的。因此重写loadClass()方法，修改加载顺序就破坏了双亲委派。</p>
<h4 id="破坏双亲委派模型的作用">破坏双亲委派模型的作用</h4>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM的可达性分析算法的笔记</title>
    <url>/Java/java%E5%9F%BA%E7%A1%80/jvm-GC-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li><h1 id="可达性分析算法基本思路">可达性分析算法基本思路</h1>
<p><img src="/assets/posts_jpg/Java/jvm/可达性分析算法基本思路.jpg"
alt="可达性分析算法基本思路" /><br />
  从根对象作为起始节点，通过引用的关系向下遍历，并标记可达对象。过程中走过的路径成为
<strong>引用链</strong> 。如果一个对象和GC
Roots之间没有引用链，即为该对象不可达，是垃圾回收对象。<br />
  在这可达性分析算法中，主要有以下几点。</p></li>
<li><h1 id="找到所有gc-roots节点根节点枚举">找到所有GC
roots节点，根节点枚举</h1>
<p>  根节点枚举，也就是找到符合作为Root条件的对象。GC
Roots主要是由栈中引用指向的对象集合成的。因此，根节点枚举就相当于从虚拟机栈、方法区等中，<strong>找到引用</strong>并把引用所指对象作为GC
Root。找到栈上的引用，是根节点枚举的关键。<br />
  JVM内存中某地址上的数据分为两种，一种是 <strong>数值型</strong>
，一种是 <strong>引用型</strong>
。可达性分析时，如果该数据为引用型，也即
<strong>指向堆中对象的指针</strong> ，就表示是需要标记的可达对象。<br />
  对于该过程而言，数值型数据并不需要，只需要引用型来标记该可达对象。因此需要有
<strong>辨别</strong>
某位置数据是否为引用型的方法，也即JVM需要记录数据的类型。有三种处理方式：主流垃圾收集器，标记对象时都是以准确式GC找到root对象的。保守式
和 半保守式不需要太关心 ：<br />
<img src="/assets/posts_jpg/Java/jvm/数值和引用的区分.jpg"
alt="数值和引用的区分" /></p>
<ul>
<li><h2 id="保守式gc">保守式GC</h2>
<p>  JVM <strong>不记录</strong> 数据类型， <strong>不能区分</strong>
某个位置上的数据是数值，还是指向堆的地址。只能在 <strong>扫描栈</strong>
时，保守的将数据 <strong>优先视为引用型</strong> ，判断该数据是否符合在
<strong>堆地址</strong>
上下边界之间等条件。如果数据不符合条件，那肯定不是引用型。就算符合条件，该数据也不一定就表示指向堆的地址，也可能就只是个值。<br />
  保守式GC，不会误杀可达对象，但可能会因为某个数值刚好和垃圾对象的地址一样，而放过垃圾对象。</p></li>
<li><h2 id="半保守式gc">半保守式GC</h2>
<p>  半保守式GC，大致上和保守式GC差不多。只是在对象上会记录类型数值这些信息。所以根据这些对象上的引用链，可以区分对象里的引用，然后顺着引用链来发现可达对象。<br />
  但是，因为是保存在对象中的信息，因此对于从栈中区分哪些是引用没有帮助。所以对找到根节点没有效果，只是方便从根节点顺着引用链向下遍历。和保守式GC一样，不能区分栈或方法区中的数值和引用。</p></li>
<li><h2 id="准确式gc">准确式GC</h2>
<p>  JVM能够准确的知道，栈中哪些位置上是指针。在当前主流虚拟机中，都通过保存指针位置到
<strong>映射表</strong> 中来实现，也就是下面提到的OOP
Map。HotSpot中，将该数据结构称为OOP Map。</p></li>
</ul>
<p>  目前 <strong>所有</strong>
的垃圾收集器，在找到根节点，也即根结点枚举这一步时，都要stop the
world。</p></li>
<li><h1 id="可达性分析时快速定位oop-map">可达性分析时快速定位，OOP
Map</h1>
<p>  OOP为ordinary object
pointer，普通对象指针。通过映射表，根节点枚举时，可以知道哪些位置是指针，不用遍历栈，即可获得GC
Roots。<br />
  对象的类信息中有记录自己的OOP
Map。通过该映射表，能知道该类的实例对象中，哪些 <strong>偏移量</strong>
位置上是指针。OOP Map映射表，就相当于告诉JVM哪些位置上是指针。<br />
  一个线程对应一个栈，一个栈中栈帧对应一个方法，一个方法记录多个OOP
Map。一个方法通过 <strong>安全点</strong> 分为多段，每一段对应一个OOP
Map。<br />
  对于 <strong>JNI</strong> 方法，没有OOP Map。因此JNI方法中的
<strong>java引用</strong> ( <strong>入参引用</strong> ，
<strong>返回值</strong> 等 ) ，需要用 <strong>句柄</strong>
包装起来。JNI方法中的引用先指向句柄，然后句柄再指向堆中对象。GC时扫描句柄，就可以得到引用所指对象。因为JNI中引用
<strong>不是直接指向</strong>
堆中对象，而是指向的句柄。因此调用JNI方法，会有句柄的
<strong>装包</strong> 和 <strong>拆包</strong> 的开销。<br />
  在HotSpot中，对象的类型信息里有记录自己的OopMap，记录了在该类型的对象内什么偏移量上是什么类型的数据。可以通过
OOP MAP 获得 GC ROOTS，以及对象类信息自己的OOP
MAP准确获得引用的对象。这些数据是在类加载过程中计算得到的。GC开始的时候，就通过OopMap这样的一个映射表知道，在对象内的什么偏移量上哪些是引用的对象。</p></li>
<li><h1 id="安全点safe-point">安全点，Safe point</h1>
<p>  方法在执行过程中，可能会导致引用关系发生改变，OOP
Map映射表就要随之更新。但引用每发生一次变化就更新，成本很高。因此JVM在运行到预先选定的位置，才更新OOP
Map。这些位置就是 <strong>安全点</strong> 。因为OOP
Map在安全点会更新，也就是说安全点的OOP Mao是准确的，因此只有
<strong>在安全点才进行GC</strong> 操作。<br />
  这些位置主要特点是： <strong>程序长时间执行</strong>
，如：1.循环末尾、2.调用方法的位置、3.方法临返回前、4.抛出异常的位置。<br />
  把这些位置设为安全点就是为了
<strong>避免长时间无法进入安全点，从而无法GC</strong>
。JVM在GC时，要等到 <strong>所有</strong> 应用 <strong>线程</strong>
处于 <strong>安全状态</strong> 。也即要么在安全点，要么在安全区。<br />
  当GC需要stop the world时，线程通过 <strong>中断标志位</strong>
发现需要挂起，会在最近的安全点主动挂起，这就是
<strong>主动式中断</strong> 。目前虚拟机使用的都是主动式。<br />
  另一种中断方式是 <strong>抢断式中断</strong> 。当需要stop the
world时，先挂起线程，如果线程不在安全点，再恢复线程运行到安全点。</p></li>
<li><h1 id="安全区域safe-region">安全区域，Safe Region</h1>
<p>  安全点只解决 <strong>运行中</strong>
的线程进入GC的问题。对于不处于运行中的线程，如sleep，block，无法到最近的安全点。<br />
   <strong>安全区域</strong> 能保证在某一段代码中，
<strong>不会变更java堆中状态，或者说不会导致引用关系变化</strong>
。而被挂起的线程认定处于安全区域内。<br />
  对于 <strong>正在执行JNI</strong>
的线程，JNI中的代码不由JVM管理。JNI执行中，认为不会影响引用关系变化。因此，执行中的JNI，也被视为在安全区中。而调用JNI时，调用的位置也会有安全点，在执行JNI
<strong>前</strong>
就需要STW线程挂起的话，也能够在这个安全点挂起。<br />
  当线程进入安全区域时，标记自己进入安全区域。就算这个时候发生GC，因为不会导致引用关系变化，所以不需要考虑安全区域内的线程。当线程
<strong>离开</strong> 安全区域时，要检查JVM是否 <strong>处于</strong>
需要stop the world阶段，换句话说 <strong>应用线程</strong> 需要
<strong>中断</strong>
阶段，如根节点枚举。如果不需要，则继续执行。否则挂起，直到阶段完成，收到离开信号。<br />
  正在在执行JNI的线程，被认为处于安全区域。而stop the
world是防止线程的执行变更引用关系。因此线程在执行JNI时，
<strong>不受</strong> stop the
world的影响。只是在离开安全区域时，要判断能否离开。</p></li>
<li><h1 id="可达性分析三色标记法">可达性分析，三色标记法</h1>
<p>  一般使用可达性分析的垃圾收集器，使用 <strong>三色标记法</strong>
进行存活对象的标记。<br />
<img src="/assets/posts_jpg/Java/jvm/可达性分析三色标记法.jpg"
alt="可达性分析三色标记法" /><br />
  由图中所示，三色标记法状态分为三种：</p>
<ul>
<li><p>黑色 ：该节点已访问，且对象中field字段的节点
<strong>全部</strong> 都访问完成，标记为黑色节点。</p></li>
<li><p>灰色
：该节点已访问，但对象中字段的节点还没访问，或者没全部访问完，标记为灰色节点。</p></li>
<li><p>白色
：没被访问到的节点。不可达的垃圾对象一定是白色节点，白色节点不一定是垃圾对象。</p></li>
<li><h2 id="三色标记法大概流程">三色标记法大概流程</h2>
<p>  一开始所有对象都在白色集合中，GC
Roots可直接关联对象标记为灰色，并从白色集合中移除，加入到灰色集合中。从灰色集合中依次取出对象，并遍历该灰色对象中的字段的对象，将遍历到的对象移出白色集合并加入到灰色集合中。当该对象的全部字段对象加入到灰色后，加入到黑色集合中。</p></li>
<li><h2
id="应用线程并发时可能出现的问题">应用线程并发时可能出现的问题</h2>
<p>  在CMS，G1等垃圾收集器中，有个 <strong>并发标记</strong>
阶段，GC线程和应用线程并发执行。应用线程执行时可能会导致引用关系变化。而
<strong>引用关系的变化</strong> 可能导致：</p>
<ul>
<li><h3 id="浮动垃圾的多标">浮动垃圾的多标</h3>
<p>  浮动垃圾是，已经标记为黑色或者灰色的对象，引用链断开，变为要回收的垃圾对象。浮动垃圾
<strong>不会影响</strong> 程序的 <strong>正确性</strong>
，只是本应该回收但没回收到的内存。因此本轮GC，不回收，下一轮再判断。</p></li>
<li><h3 id="存活对象的漏标">存活对象的漏标</h3>
<p>  因为应用线程的并发执行，导致 <strong>黑色</strong>
对象的引用关系发生变化，产生了 <strong>黑色-白色</strong>
的引用链。而黑色对象被认为是已经完成遍历的对象。因此黑色对象不会被重新遍历，导致新引用链的白色对象，不会被访问到，一直会是白色对象，造成还在使用的存活对象，被视为垃圾对象回收。<br />
<img src="/assets/posts_jpg/Java/jvm/存活对象的引用发生改变.jpg"
alt="存活对象的引用发生改变" /><br />
  如图所示，原引用链灰色指向白色消失 且 新引用链是黑色指向白色。<br />
  原本存在的 B指向C 的引用链删除，而出现了 A指向C 的引用链。因为 A
已近标记为黑色，因此不会再遍历。导致还在使用的对象
C，没有被访问到视为垃圾对象。</p></li>
</ul></li>
<li><h2 id="漏标的解决方法">漏标的解决方法</h2>
<ul>
<li><h3 id="并发时创建新对象的特殊处理">并发时创建新对象的特殊处理</h3>
<p><img src="/assets/posts_jpg/Java/jvm/新创建的对象.jpg"
alt="新创建的对象" /><br />
  对于并发阶段创建的新对象，是不会被视为垃圾对象的。垃圾收集器会把并发阶段创建的新对象存储在
<strong>指定区域</strong> ，不会被回收。</p></li>
<li><h3 id="写屏障">写屏障</h3>
<p>  写屏障是解决漏标的基础。写操作就是在赋值操作时，添加额外处理，类似与AOP。不同的垃圾收集器，有着不同的处理方式：</p>
<ul>
<li><h4 id="cms-增量更新">CMS 增量更新</h4>
<p>  CMS垃圾收集器，目前差不多淘汰。CMS处理方式在写屏障的基础上，通过增量更新解决漏标，针对发生漏标的第二条件。解决思路就是，针对新增的引用进行修改。<br />
  当发生黑色节点指向白色节点时，将黑色指向白色这个新的引用关系记录。在
<strong>重新标记</strong> 阶段，再扫描 <strong>记录的引用链</strong>
，防止漏标。<br />
  对于并发阶段的新对象，CMS会预留空间用来存放新的对象。</p></li>
<li><h4 id="g1-原始快照satb">G1 原始快照SATB</h4>
<p>  G1在写屏障基础上，通过 SATB
解决漏标。主要针对发生漏标的第一条件。解决思路就是，记录删除的引用。<br />
  当灰色指向白色的引用链消失时，记录下该旧引用关系，在
<strong>最终标记</strong>
阶段，扫描旧的引用关系来防止漏标。相当于G1收集器会按照
<strong>开始扫描时</strong> 的 <strong>对象引用关系快照</strong>
来扫描。<br />
  G1收集器在并发阶段中，通过Region中的两个 <strong>TAMS</strong>
指针来划分出一个空间，存储新创建的对象。</p></li>
</ul></li>
</ul></li>
</ul></li>
<li><h1 id="记忆集和卡表">记忆集和卡表</h1>
<p>  解决新生代，老年代的跨代引用。待补充。。。</p></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
        <tag>可达性分析算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM的语法糖</title>
    <url>/Java/java%E5%9F%BA%E7%A1%80/jvm-%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    <content><![CDATA[<!--
jvm 语法糖 + lambda 原理 + java stream + ? + 泛型 + default
-->
<p><!-- 
 java stream流
 lambda表达式 就相当于 一个 匿名函数/方法 

 list.forEach(s -> System.out.println(s));
  //                      变量  -> {return}
 Collections.sort(list, (o1,o2) -> o1.compareTo(o2));
 
 Collections.sort(list, (o1,o2) -> {
     return o1.compareTo(o2)
 });

 list.stream().filter(s -> s.startsWith()).collect(Collections.toList());

 list.stream().map(s -> s.lengt())
 --></p>
<p><!--
  java源码 === java编译器 ===> class文件 字节码 === JVM (包括JIT编译器 + java解释器) ===> 机器码

  字节码 : 是源码和机器码之间的中间代码，在JVM上运行
  javac : Java Compiler，java编译器 (前端编译器)
  JIT : Just In Time，JVM一部分
  AOT : Ahead Of Time，JVM一部分，应用程序部署之前将字节码预先编译为本地机器码的编译器

  源码转化为字节码后，运行程序有两种选择：一种是使用 Java 解释器 (java interpreter) 解释执行字节码，另一种则是使用 JIT 编译器将字节码转化为本地机器码

  在 Idea 的 SDK中，涉及到两项JDK相关路径：
    class path：JDK自带的class文件路径。JDK源码官方已经编译好的 class文件，不必再从 编译 JDK source 开始。代码中调用的JDK API，都是在编译运行后 直接从 class文件中调用。不是 jdk source 一起编译后的结果。  
    source path：JDK源码文件，可以阅读修改 源码，想让修改后的源码生效，需要 重新编译并将 生成的class 取代 class path中的 原文件。这样做没什么好处。
                 可以在 项目中 添加 jdk源码 模块，并使用 该模块的接口，在编译运行项目后，就能绕过 官方编译的JDK class。 
  具体可以搜索：编译JDK源码

  需要查看源码 (如果查看 依赖的库、或使用的框架 的源码，也需要添加到 source path)，记得添加 source path。不然会跳转到 class文件，只能查看接口 命名等，无法看到具体设计。


  泛型的协变和逆变：extends和super。本质就是指定 泛型的参数范围：
   ? extends E ： E 的 任何一个 子类
   ? super E ： E 的 任何一个 超类
 --></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>类加载器</tag>
        <tag>语法糖</tag>
      </tags>
  </entry>
  <entry>
    <title>保留文件</title>
    <url>/Java/java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Mybatis-A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!--
### sql预编译  
&ensp;&ensp;数据库执行sql语句时，需要词法分析，语法分析，优化器优化等行为。而某些场景sql语句使用时，除了 **值** 不同，表、字段等都是重复的。因此可以使该sql **一次编译，反复执行** ，在其他不变的情况下，只修改值的变化。  
&ensp;&ensp;通过sql预编译，将值用 **占位符** 替代，将sql语句 **模板化** ，从而达到sql语句的一次编译，变更值的多次运行，而后注入的参数也不需要进行编译。多次使用时不再需要编译，省去了分析，优化阶段。  
&ensp;&ensp;使用预编译，可以提高执行效率。也能够防止 **sql注入** ，后注入的参数，不会被当作sql语句，而是当作参数值。因此可以防止破坏数据库的语作注入。s

### #{}和${}的区别  
&ensp;&ensp;${} 不会对参数进行特殊处理。#{} 会把参数当成字符串处理。当包含表名、字段名这种参数时，两种方法的区别比较明显：  
&ensp;&ensp;&ensp;&ensp;select * from #{table} 相当于 select * from 'table'   
&ensp;&ensp;&ensp;&ensp;select * from ${table} 相当于 select * from table  
&ensp;&ensp;${}是字符串替换。#{}是预编译处理。#{}可以防止sql注入，安全性更高。

### 动态sql原理

Mybatis
Mybatis plus
-->
]]></content>
      <categories>
        <category>java开发框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的 IOC 和 AOP</title>
    <url>/Java/java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Spring-IOC%E5%92%8CAOP/</url>
    <content><![CDATA[<ul>
<li><h1 id="ioc">IOC</h1>
<ul>
<li><h2 id="控制反转-ioc">控制反转 IOC</h2>
<p>  Spring Ioc容器控制bean的生命周期。即bean的创建，销毁等。</p></li>
<li><h2 id="依赖注入-di">依赖注入 DI</h2>
<p>  通过接口，构造方法，注解等方法，由Ioc容器动态的将某个依赖，注入到组件中。相当于bean之间的关系由容器完成。</p></li>
<li><h2 id="bean的生命周期">bean的生命周期</h2>
<p><img src="/assets/posts_jpg/Java/java-framework/bean生命周期.jpg"
alt="循环依赖" /><br />
  在bean执行构造方法实例化后，通过依赖注入填充属性，而此阶段可能发生循环依赖。如果bean实现了Aware接口，则按图中顺序执行实现的方法。<br />
  BeanPostProcessor就是后置处理器，AOP就是在初始化
<strong>后置阶段</strong> 实现。BeanPostProcessor是
<strong>针对所有</strong> 的bean的，每个bean在生命周期中，都会执行
<strong>所有的</strong>
BeanPostProcessor中方法，包括实现接口自定义的BeanPostProcessor。可以在方法中添加条件判断，让自定义的BeanPostProcessor跳过不符合条件的Bean。<br />
  bean的初始化阶段，就是在使用bean之前，执行初始化方法中的内容，来扩展功能，如读取mysql中数据。</p></li>
<li><h2 id="三级缓存解决循环依赖">三级缓存解决循环依赖</h2>
<ul>
<li><h3 id="提前曝光">提前曝光</h3>
<p>  解决循环依赖，核心即为 bean 的提前曝光。只执行
<strong>构造方法</strong> ，完成对象创建，没有执行
<strong>注入依赖</strong> 及 <strong>初始化</strong> 。</p></li>
<li><h3 id="循环依赖的发现机制">循环依赖的发现机制</h3>
<p><img src="/assets/posts_jpg/Java/java-framework/循环依赖.jpg"
alt="循环依赖" /><br />
  当生成A的bean时，会通过
<strong>isSingletonCurrentlyInCreation()</strong> 方法先判断
<strong>该beanName对应的bean</strong>
是否处于正在创建，如果没有就将该beanName添加到一个
<strong>set集合</strong>
中，表示该beanName的bean正在创建，当bean生成流程全部执行完时再移除集合。<br />
  通过 <strong>createBeanInstance()</strong> 方法实例化bean，然后通过
<strong>populateBean()</strong>
方法进行填充属性，此时无法直接给字段b填充B的bean，因此开始实例化B的bean并填充属性，且在实例化该bean时，将该bean的beanName添加到
<strong>"正在创建"set集合</strong> 中。<br />
  此时填充属性发现，B依赖的A存在于set集合中，表示A正在创建中。因此发现发生了循环依赖。<br />
<img src="/assets/posts_jpg/Java/java-framework/bean正在创建中集合.png"
alt="bean正在创建中集合" /></p></li>
<li><h3 id="一级缓存-singletonobjects">一级缓存 singletonObjects</h3>
<p><img src="/assets/posts_jpg/Java/java-framework/一级缓存.jpg"
alt="循环依赖" /><br />
  假设A，B，C之间的关系如图所示。创建B的bean时，在填充属性时会创建一个A的bean。当创建C的bean时，在填充属性时也需要A的bean。此时如果再创建一个A的bean，就破坏了beanName和bean之间的单例关系。因此需要一个容器保存
<strong>创建完成</strong> 的bean。<br />
  使用 <strong>ConcurrentHashMap</strong> 保存完整的bean。</p></li>
<li><h3 id="二级缓存-earlysingletonobjects">二级缓存
earlySingletonObjects</h3>
<p><img src="/assets/posts_jpg/Java/java-framework/二级缓存.jpg"
alt="循环依赖" /><br />
  假设A，B，C之间的关系如图所示。在创建A的bean时，在填充属性时会创建B的bean。而B的bean时需要用到A的bean，而此时A的bean还没有完成。为了进行下去，就需要用到二级缓存，来保存实例化，但未注入依赖的bean，也就是
<strong>不完整</strong> 的bean。<br />
  使用 <strong>HashMap</strong>
保存不完整的bean。只有一级缓存是用concurrentHashMap，其他使用的为HashMap，但是会通过
<strong>synchronized</strong> 同步锁来实现线程安全。</p></li>
<li><h3 id="三级缓存-singletonfactories">三级缓存
singletonFactories</h3>
<p>  解决循环依赖的核心是 <strong>提前曝光</strong>
，也就是在bean构造后，就要有一个容器来保存，以供后面可能发生的循环依赖来使用，也就是
<strong>singletonFactories</strong>
。在构造阶段，Spring不知道是否会发生循环依赖。如果bean涉及到AOP，也就是需要代理对象。<br />
  正常流程中，生成代理对象bean，是在完成初始化等操作后，添加到singletonObjects
<strong>之前</strong>
执行。Spring采取发生依赖循环时将AOP生成的代理对象bean
<strong>提前</strong>
。因此三级缓存提前曝光的是SingletonFactory对象。<br />
  遇到循环依赖时，如果需要提前aop代理bean，singletonFactory.<strong>getObject()</strong>创建代理bean，并保存到earlySingletonObjects中。如果不涉及到AOP，SingletonFactory本来就保存了原始bean，getObject()方法返回原始bean，保存到earlySingletonObjects中。</p></li>
<li><h3 id="三级缓存-和-二级缓存">三级缓存 和 二级缓存</h3>
<p>  三级缓存中， <strong>提前曝光的是singletonFactory对象</strong>
。发生循环依赖时通过该对象可以得到，bean或者代理bean，再加入到二级缓存中。<br />
  如果没有发生循环依赖，那么bean的生命周期过程不受影响。只有发生循环依赖且涉及到AOP生成代理对象，才会影响本来的生命周期，需要将AOP提前。<br />
  如果不采用三级缓存，取消掉singletonFactories。那么需要将earlySingletonObjects提前，在bean构造后就直接保存到earlySingletonObjects中，
<strong>提前曝光的是未完成的bean</strong> 。因为在
<strong>构造阶段不知道是否会发生循环依赖</strong>
的。在只有二级缓存中，如果涉及到AOP，那么必须在bean构造后就生成代理bean，并将代理bean保存到earlySingletonObjects中。就算没有发生循环依赖，那也已经AOP提前了，破化了原来的生命周期流程。</p></li>
</ul></li>
</ul></li>
<li><h1 id="aop">AOP</h1>
<ul>
<li><h2 id="jdk-proxy-jdk动态代理">JDK Proxy JDK动态代理</h2>
<p>  代理类实现 <strong>InvocationHandler</strong> 接口，实现
<strong>invoke()</strong> 方法。通过
<strong>Proxy.newProxyInstance()</strong> 方法生成动态代理对象。<br />
<img src="/assets/posts_jpg/Java/java-framework/newProxyInstance1.png"
alt="ProxyInstance" />   newProxyInstance()方法内部通过
<strong>getProxyClass0()</strong> 方法生成动态代理类的
<strong>class对象</strong>，其中动态代理类的Class字节码只在内存中。<br />
<img src="/assets/posts_jpg/Java/java-framework/getProxyClass0.png"
alt="getProxyClass0" /><br />
  在class文件中，类的接口数量通过 <strong>2字节</strong>
的interfaces_count表示，因此一个类的接口数量上限为2<sup>16</sup>个。<br />
  ProxyClassFactory工厂的apply方法中，通过
<strong>ProxyGenerator</strong>
类的<strong>generateProxyClass()</strong>方法，生成动态类的字节码。 <img
src="/assets/posts_jpg/Java/java-framework/generateProxyClass.png"
alt="getProxyClass0" /><br />
  生成的动态类类名一般为$Proxy +
编号，该类实现了被代理类的接口，且继承自Proxy类。Proxy类有参构造方法接收InvocationHandler接口实现类，作为字段h，动态代理类实现的方法，就是
<strong>调用</strong>
InvocationHandler接口实现类中重写的invoke()方法。JDK动态代理是通过实现被代理类的接口中的方法，来完成调用invoke()方法，因此JDK动态代理使用时，被代理类
<strong>必须有接口</strong>。</p></li>
<li><h2 id="cglib-proxy-cglib动态代理">CGLIB Proxy CGLIB动态代理</h2>
<p>  代理类实现 <strong>MethodInterceptor</strong>
接口，实现intercept()方法。CGLIB和JDK的区别在于，CGLIB通过
<strong>继承关系</strong>
来实现被代理类功能的扩展，就相当于重写父类方法，然后在子类方法中添加功能，然后通过super调用父类方法。因此CGLIB动态代理不能用于
<strong>final修饰</strong>
的类或者方法，因为final修饰的不能继承。</p></li>
<li><h2 id="spring事务">Spring事务</h2>
<ul>
<li><h3 id="spring事务的传播性">Spring事务的传播性</h3>
<ul>
<li>Propagation.REQUIRED：支持当前事务，如果当前有事务，就运行在当前事务中。如果没有则新建事务。<br />
</li>
<li>Propagation.SUPPORTS：支持当前事务，如果当前有事务，就运行到当前事务中。如果没有，就以非事务方式执行。<br />
</li>
<li>Propagation.MANDATORY：支持当前事务，如果当前有事务，就运行在当前事务中。如果没有，抛出异常。<br />
</li>
<li>Propagation.REQUIRES_NEW
：不支持当前事务，新建事务，如果当前有事务，则挂起当前事务。该方法不受调用者影响，也即
父级(调用该方法的方法) 抛出异常，不影响该方法。<br />
</li>
<li>Propagation.NOT_SUPPROTED：不支持当前事务，以非事务方式执行，如果当前有事务，则挂起当前事务。<br />
</li>
<li>Propagation.NEVER：不支持当前事务，如果当前存在事务，则抛出异常。<br />
</li>
<li>Propagation.NESTED：如果当前没有事务，就新建事务，如果当前有事务，成为父事务的子事务，只有父事务结束，才提交。子事务异常不影响父事务。父事务异常影响子事务而回滚。</li>
</ul></li>
</ul></li>
<li><h3 id="transactional-的实现"><span class="citation"
data-cites="Transactional">@Transactional</span> 的实现</h3>
<p>  Spring事务通过动态代理实现。在代理类中，通过jdbc等开启事务，再执行target的方法。<br />
<span id="3"></span> <img
src="/assets/posts_jpg/Java/java-framework/spring注解注意点.png"
alt="spring注解注意点" /><br />
  上图中，当 test2()
被@Transactional修饰时，因为事务是通过动态代理实现的，因此通过<strong>this</strong>调用方法，不会使注解生效，只会执行方法，而不涉及到事务。只有代理对象执行时，原方法被代理类增强扩展，开启了事务。this
和 注入的command1不是同一个对象，command1是代理对象。<br />
  command1对象调用 test1() 方法，执行代理类增强部分，再调用target的
test1() 方法。因此，会执行图中源码 test1()
内容的依旧是原对象。this，就是该原对象，不会开启事务。</p>
<ul>
<li><h4 id="transactional-失效的场景"><span class="citation"
data-cites="Transactional">@Transactional</span> 失效的场景：</h4>
<ul>
<li><p>数据库存储引擎不支持事务：存储引擎本身需要支持事务。<br />
</p></li>
<li><p>目标方法不是public修饰：Spring需要通过AbstractFallbackTransactionAttributeSource类来获得@Transactional属性配置信息。该类中的方法会判断目标方法修饰符是否为public。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">TransactionAttribute</span> <span class="token function">computeTransactionAttribute</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">allowPublicMethodsOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 省略</span>
        <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>方法调用问题：this调用和注入的代理对象调用区别。代理类对象扩展了原类对象方法，因此只有通过代理对象调用方法，才会开启事务。<br />
</p></li>
<li><p>方法无法抛出异常：如在方法中使用try
catch，捕获异常，则事务不能回滚。可以在捕获异常后，在catch代码块中再抛出异常来达到回滚。<br />
</p></li>
<li><p>目标方法所在类没有被Spring容器管理：也就是没有生成对应的bean，如类没有用注解声明为组件。</p></li>
</ul></li>
</ul></li>
<li><h3 id="transactional方法的继承"><span class="citation"
data-cites="Transactional方法的继承">@Transactional方法的继承</span></h3>
<p>  父类中有@Transactional方法，子类继承父类，不管是否重写该方法，子类的bean都是动态代理对象。</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>java开发框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>保留文件</title>
    <url>/Java/java%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/Spring-SpringBoot-A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<!--
### Spring Boot、Spring MVC 和 Spring 有什么区

### Springboot 有哪些优点

### 约定优于配置

### Spring Boot 的核心注解是哪个,主要由哪几个注解组成的

### Spring Boot 自动配置

### Spring Boot Starter 的工作原理


### springboot 启动原理


### springboot 原理

### @Transactional
  spring会创建 动态代理
-->
]]></content>
      <categories>
        <category>java开发框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>go学习笔记</title>
    <url>/Go/go%E5%9F%BA%E7%A1%80/go-Effective/</url>
    <content><![CDATA[<!--
1 go每声明一个变量 相当于 内存中的一个新地址  
   
2 go方法及函数 都是 值传递，形参 都是 实参 的副本，但是 对于指针，或者 隐式指针来说，就算是 值副本，指向的地址依旧不变  

3 go的赋值操作 都是 副本赋值 原数据不会因副本变动而变动，但是 对于指针，或者 隐式指针来说，就算是 值副本，指向的地址依旧不变  

4 结合 2.3 总的来说，go 和 java一样，没有引用传递，都是值传递。只是传的是 指针 或者 引用 指向的地址值。  

5 切片 和 map ，通道 这些当相当于 指针，是隐式指针， 这些 结构 都需要 make() 函数 初始化。  

6 类型 或者 该类型 指针 提供了 方法1，则 该变量 或者 该指针 都能使用该方法1，go编译器 会自动转换 变量或指针  

7 类型 实现了 接口 的 方法1，则该 类型 变量 和 指针， 都能赋值给 该接口变量  

8 类型指针 实现了 接口 的 方法1，则只有 类型指针，赋值给 该接口变量  

9 go 中 需要将 字符 理解成 byte，s := "123", s[0] 为 '1'，如果输出 s[0] ，结果是49，也就是 相当于在go中会直接把 字符型 转为 byte型,不能输出'1'。java中可以输出字符，当把 字符 和 整型相比较时，字符型才会转为整型  

10 go的位移中，>> 高位 补符号位的值 ; << 低位补0 ; go中没有和java一样直接提供Integer.MIN_VALUE，这样的参数。因此可以直接使用位运算 获得值。  

11 方法 函数
-->
]]></content>
      <categories>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title>保留文件</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%8E%E8%AE%A1%E7%BD%91%E8%A7%92%E5%BA%A6%E7%9C%8B%E5%B8%A6%E5%AE%BD%E9%99%90%E9%80%9F/</url>
    <content><![CDATA[<!--
路由器限速
链路层
IP层限速
TCP层限速
应用层限速
-->
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>从抓包工具查看网络协议</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BB%8E%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<!-- ## 草稿版


### Wireshark抓包

抓包就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等

### Fiddler抓包
抓Http Https相关包，能解析Https加密后的包，相当于一个HTTP代理器，发送、接收的HTTP包，都先经过Fiddler。 -->
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>wireshark</tag>
        <tag>fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title>保留文件</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%92%8C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<!--
---
layout: post
title:  "数据通信和协议"
date:   2022-12-14 15:41:00 +0800
updated:   2023-04-25 15:41:00 +0800
tags:
  - 协议
categories:
  - 计算机网络
description: 数据通信和协议
---

无线传输是指通过电磁波或光波等无线信号来传输信息的一种通讯方式

无线射频通讯技术 : wifi、蓝牙、nfc
  无线电信号

索尼ps4、ps5 ：ps remote 或 串流直连， Ps4、ps5自身就会发出一段wifi信号，也就是说设备直连，其实就相当于 ps4、ps5 自己开了个热点，而只有 psv 或者 psportal 能连接上，此时用手机查看wifi，可以看到，ps4、ps5 前缀的wifi。

-->
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>保留文件</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<!--
TTL 丢弃前最大网段数量
路由器AP、路由、中继、桥接模式
-->
<!--
### 子网掩码

#### &ensp;&ensp;子网掩码的作用

#### &ensp;&ensp;判断计算机是否在同一网络下
&ensp;&ensp;计算机A 网络配置 ipA，子网掩码 mA。计算机B 网络配置 ipB，子网掩码 mB。
当 ipA & mA = ipB & mB 时，计算机A 和 计算机B 在同一网络下。

### 网关

#### &ensp;&ensp;网关的作用

#### &ensp;&ensp;计算机之间是否能通信
&ensp;&ensp;计算机A 网络配置 ipA，子网掩码 mA。计算机B 网络配置 ipB，子网掩码 mB。  
&ensp;&ensp;对于 计算机A 来说，ipA 所在网络为 ipA & mA，ipB 所在网络为 ipB & mA。  
&ensp;&ensp;对于 计算机B 来说，ipA 所在网络为 ipA & mB，ipB 所在网络为 ipB & mB。
&ensp;&ensp;对于不同网络下的通信，需要网关转发。在同一网络下，不需要网关转发。  
&ensp;&ensp;如果 子网掩码配置问题，导致 计算机A的角度看，和计算机B是同一网络，计算机B的角度看，和计算机A不是同一网络。就会发生，计算机B 请求 计算机A ，通过网关转发，请求到达 计算机A。但是 计算机A 请求 计算机B ，不会走网关，因此 计算机A 请求无法达到计算机B。


局域网由路由器产生，路由器即为网关  因为路由器既处于公网内，又处于私网内

### 路由

#### &ensp;&ensp;路由和路由表和路由器
路由就相当于，根据目的ip，判断数据包发送给下一个接收者。也就是路由器到下一个路由器的传输路径。  

计算机如果有多个网卡，那么发送的数据包走哪一条路线，就会根据本地的路由表来判断。路由器中的路由表，来判断当前数据包，走哪一条路由。  

路由器通过动态维护路由表来反映当前的网络拓扑。

-->
<!--
## 协议 和 在浏览器输入URL后的流程

### 协议
#### &ensp;&ensp;对协议的理解
&ensp;&ensp;协议相当于通信规则。通过规则，可以让 发送端 知道要发送哪些数据，或者发送数据的格式。通过规则，能让 接收端 能知道怎么处理对方发送过来的数据。  
&ensp;&ensp;不应该理解成 协议 实现了 网络通信。物理上来讲，实现了数据传输的是，能将 数字信号 和 电信号、光信号 之间转换 的网卡 及 进行传输的线路。而协议，在物理传输基础上，把数据传输和数据接收 变为了 通信。  
&ensp;&ensp;操作系统中，维护网络通信状态的 ，也就是控制信息，分为两种，一种是内存中的控制信息，一种是传输是协议头部的数据。通过 控制信息 的 交互，及内存中的控制信息的更新，来维护计算机 通信状态。  
&ensp;&ensp;像udp协议 + ip协议，让 发送端发送数据 时，能让 发送端，接受端 知道 对方的ip地址及程序端口号。  
&ensp;&ensp;像tcp协议 + ip协议，能让 知道对方ip及端口号的基础上，通过tcp头部的序列号，确认应答，确认号 等，能实现 可靠传输，也即 辨别哪部分数据丢失 以及 丢失包重传 等功能。  
&ensp;&ensp;而tcp协议的 面向连接。这里的连接 也就相当于 session 这种会话。这个连接，更像是双方交换 控制信息 并 更新控制信息 来 维护 发送端 知道 接收端，接收到哪一步，哪一个网络包了，接收端 告诉 发送端 自己接收到哪里 这么一种 关系，直到 断开连接 也就是 结束会话。  
&ensp;&ensp;当发送端发送后，更新系统的控制信息，就像把某一状态值改为 已发送。而 接收端 收到数据后，读取协议头部的数据，这就相当于是 控制信息的交换/交互。然后 接收端在对 请求做出回应。发送端 通过控制信息 能知道自己已发送，如果 没有接收到回应，应用程序，可以通过这个状态来实现重传。就算是 只用 udp协议，通过控制信息，也能知道 自己是否收到了 回应。但是 tcp协议 的可靠是指，能具体的知道 是哪个序号的包丢失 等

#### 对协议的理解

没有网络协议，计算机之间 无法识别和理解彼此发送的数据。网络协议提供数据的格式、结构等，以供 接收端识别接收的数据。  
简单来说，应用程序都有一个唯一的端口号，用来标识该应用程序。当接收端收到一个数据包时，它会通过TCP协议检查数据包的目的端口号，以确定该数据包是发给哪个应用程序的。同时，接收端也会通过IP协议检查数据包的源IP地址，以确定该数据包来自哪个计算机。

因此，接收端通过TCP协议识别发送端的程序端口号，并通过IP协议识别发送端的IP地址，从而确定数据包的来源和目的地


#### &ensp;&ensp;协议干了什么
&ensp;&ensp;数据通信中，涉及到多个协议，而不同的协议负责不同的部分，而这些协议在通信时干了什么，换个角度说，就是这些协议在数据传输，附带了哪些数据。而这个数据，也就是 协议头部，数据格式要求等。就像，HTTP协议规定的数据格式，TLS协议双方协商的加密方式，UDP协议头部带上的 双方端口号，IP协议带上的 ip地址号 等。这些 数据格式、内容 及 报文头部带的数据，就相当于 协议在数据通信时的行为。

### 在浏览器输入URL后的流程

#### &ensp;&ensp;1.浏览器解析URL
&ensp;&ensp; URL最前面指定的应用层协议，让浏览器知道 是哪个协议，以及用该协议的方式解析链接，以及生成对应的报文头部。域名让发送端知道，接收端是谁。域名后的文件路径，让发送端知道，请求接收端上的哪个文件。最多的场景，一般是 在地址栏 输入 http前缀的url，就算没有协议前缀，也是默认的http协议。浏览器的地址栏 已经指定了 Http协议的 请求的METHOD为GET。解析URL后，浏览器就会生成请求报文，然后依赖操作系统发送。


#### &ensp;&ensp;2.域名转换ip地址
&ensp;&ensp;DNS，本地DNS缓存，路由器DNS缓存，DNS服务器的注册信息表。客户端通过操作系统，基于UDP向DNS服务器发送请求。每个域名都要把自己的ip注册记录到自己的上级域名中。根域ip总共只有13个，因此每个DNS服务器记录根域ip压力不大。当计算机X发送DNS请求后，DNS服务器A 会从注册表中查询，如果查询不到，就会直接委托根域，然后自上而下查询。根域DNS服务器查询自己的注册表，返回对应的一级域名ip给A，然后A再请求一级域名，一级域名DNS服务器再查询自己的注册表，返回对应的二级域名ip给A，依次类推，直到 目标域名的 上级域名DNS服务器B，B会返回目标域名的ip给A，然后A再返回给 计算机X，这样计算机就获得了目的ip。

#### &ensp;&ensp;3.Socket建立连接
&ensp;&ensp;socket  建立连接，就是 tcp建立连接的三次握手

#### &ensp;&ensp;4.数据发送与接受
&ensp;&ensp;涉及到 tcp 滑动窗口等。如果是https协议，那么浏览器在通过Socket库建立了socket连接后，不会马上发送http请求报文，而是先发送ssl/tls报文，通过tls四次交互，涉及到 三个随机数，证书，约定的加密算法等过程。在这部分完成后，发送端就会 将 http请求报文加密，然后再发送给 接收端。

#### &ensp;&ensp;5.Socket断开连接
&ensp;&ensp;socket  断开连接，就是 tcp断开连接的四次挥手


# 正向代理
  代理客户端

# 反向代理
  代理服务器

# IPv4 和 NAT 和 端口映射
网络地址转换（NAT）来将内网地址转换为公网地址
端口映射：NAT中 内网地址 都会转为 一个公网地址，因此 网关需要记录 映射表。 

# IPv6 和 IPv4
## IPv6 和 代理服务器
   临时 IPv6 : 临时 ip 是真正暴露在外网的 ip。用于保护 ipv6 的隐私性。访问外网真正使用的地址，定时更换保护隐私。网关防火墙在默认配置下只允许使用临时IPv6地址通过。设备可根据隐私保护的需要生成任意数量临时地址。
-->
<!--
### 蓝牙 与 通信 与 协议
### LDAC协议

### DDOS

### Cloudflare
  先跳转到 cf验证 再跳转到目标链接


## VPN Virtual Private Network 虚拟专用网络

  利用 互联网 (互联网并不安全，私网数据传输安全) 作为 数据报文传输的载体，在 节点之间 安全的传输 报文 ，提供 如在私网中传输报文一般的安全性。在逻辑上 像连通两个节点的专用链路，这就是 VPN技术。简单来说，就是在节点之间安全的传输数据。

  VPN 技术原理 是 ：
  
  ###数据加密
    VPN常见的加密协议 :　PPTP TLS IPSec 
  
  ###身份认证 
  
  ###数据完整性验证 

  ------------------------ 下面这些 随便复制的 后续整理------------------------------------------

  连接两个节点，真正的拉一条线不现实，那就虚拟一条这样的线路出来，感觉真的把两个节点连接一起一样，而这个技术就是VPN

  VPN是一种通过公共网络（如互联网）建立加密连接的技术，用于在远程位置之间创建私密的通信通道。通过VPN，用户可以安全地访问公司网络或其他私有网络资源，就像是直接连接到了这个网络一样

  VPN (Virtual Private Network) 利用隧道协议，使用户通过公网传递内网的消息，就好像直接连接到内部网络一样远程访问内网的资源。
  通过建立VPN连接，公网用户就可以像在内网一样访问内网中的服务

    
  VPN 是 技术或着说思想，VPN可通过服务器、硬件、软件等多种方式实现
  
  利用隧道协议（Tunneling Protocol）来达到发送端认证、消息保密与准确性等功能。VPN是通过使用专用线路或在现有网络上使用隧道协议建立一个虚拟的点对点连接而形成的

  内网穿透就是一种能够实现外网访问内网的技术
  
  专用网络 Private Network ：专用网络 也就是 私网。使用私有IP地址空间的网络。专用网络保证信息流的安全性和完整性
  虚拟专用网络 Virtual Private Network ：指的是在公网上建立专用网络的技术。

  私网IP无法直接连接互联网，需要使用网络地址转换（Network Address Translator，NAT）或者代理服务器（proxy server）来实现。与公网IP相比，私有IP是免费的，同时节省了IP地址资源，适合在局域网使用
  私网IP属于非注册地址，只能在组织机构内部使用。也就是说，私网IP是不会出现在互联网上的，无法直接使用它们来访问互联网，而只能在本地连接也就是局域网中使用。



  ### 隧道
  隧道技术： 实现两个节点间的安全通信。可以想象成：在公网中建立一个安全隧道来连接两个私网并传输数据包，其实就是 隧道协议对数据包加密了。
  TLS就是常见的隧道协议。
  
  隧道是一种使用 网络不支持的协议 在该网络中传输数据的方法
  隧道的工作原理是对数据包进行封装：将数据包包装在其他数据包内
  


## 网络代理 和 代理协议
  代理：
  HTTP 网页代理
  HTTPS 安全网页代理
  FTP 代理
  SOCKS 代理

  SOCKS5是传输层代理协议
  HTTP是网页代理协议

## 网络代理原理
   原理都是把设备A上的流量通过某种方式转发到设备B上。大致流程为：
    1. 设备A 的软件a(浏览器)对 目标服务器T 发送请求。将 请求发送给 代理服务器B。
           如果设备A 是通过代理工具 (代理软件 != 代理协议，clash v2ray 是软件工具; SS Trojan 是协议。代理工具 一般支持多种 代理协议) 、则将 请求发送给 代理软件的接入端，软件再发送请求给 代理服务器B。  
           像clash (基于规则的代理软件工具) 这种代理软件的 系统代理功能，一般是通过指定 网络代理 实现。windows系统 可以通过在 '设置 -> 网络和Internet -> 代理' 中查看。
           大概流程：流量发送给 代理服务器，也就是 127.0.0.1:软件端口，软件 根据 clash规则　选择出站协议(SS SSR Trojan VMess) 加密信息。
    2. 设备B 再将请求发送给 目标服务器T，发送回的相应也是如此。 


    不管代理软件，这些软件都会在 设备A 上监听一个端口来作为代理的接入端。Clash 默认 7890端口。可以通过设置，使某个软件的流量全部指向这个端口上。
    通常情况下，这些监听的端口使用 Socks5代理 或 HTTP代理。区别在于，HTTP代理只能够代理HTTP协议的流量，SOCKS5则支持代理几乎所有的TCP和UDP流量。

    代理软件就会修改系统设置中的代理选项。但是，系统设置中的代理往往只可设置为HTTP代理，而且这个HTTP代理只对当前系统上web浏览器有效。
    这也就是为什么明明设置了系统代理，访问GitHub也很快，但在命令行里克隆一个GitHub的仓库却很慢的原因。在命令行下，执行git命令也就是直接执行git的二进制文件，跟你设置的系统代理是没有关系的。

    利用 VPN 或 SS 或 Trojan 等 实现绕过GFW的原理，大致上都是：利用 协议 对数据进行加密 来绕过 GFW的明文检测，利用 代理服务器 来绕过 GFW的ip检测。


### TAP 虚拟二层网卡
TAP模式其实就是在设备上利用技术手段安装一个虚拟的”网卡”，工作于 数据链路层。从而使得系统所有的流量都能经过代理软件。

### TUN 虚拟三层隧道网卡
TUN模式则和TAP模式异曲同工。工作于 网络层，不需要虚拟的TAP设备。

-->
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP 和 HTTPS 协议</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE/HTTP%E5%92%8CHTTPS%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<!--
请求头中参数 Host 作用
  一台计算机上可以运行多个虚拟主机，每个虚拟主机都可以使用 相同的IP地址 。在这种情况下，Host请求头用于指定请求发送到哪个虚拟主机
  当一台计算机上有多个虚拟主机时，Host参数 可以告诉服务器使用哪个虚拟主机
或者
  因为 一个 域名 对应 一个 ip，一个 ip 可对应 多个 域名
  所以 Host中 指定的域名
-->
<ul>
<li><h1 id="http协议">HTTP协议</h1>
<p>  Http协议是应用层协议，无状态 且
不干扰传输层协议。因此在数据传输时，Http既可以基于Tcp协议，也能基于Udp协议。浏览器默认访问服务器的80端口，相当于访问的是，www.abc.com:80。</p>
<ul>
<li><h2 id="http-1.0">Http 1.0</h2>
<ul>
<li><h3 id="短连接">短连接</h3>
<p>  连接不可复用，每次请求都要三次握手，成本高，效率低。</p></li>
<li><h3 id="短连接的解决办法">短连接的解决办法</h3>
<p>  在报文头部字段的Connection字段上，修改为Connection:
keep-alive。</p></li>
<li><h3 id="请求-响应机制-导致的-http1.0-队头阻塞">请求-响应机制 导致的
Http1.0 队头阻塞</h3>
<p>  队头阻塞就相当于，队首没处理完，后面的请求在排队。在http1.0中，必须接收到前一个请求的响应，才能发送下一个请求。如果上一次请求的响应还没收到，后续的请求就被阻塞了。因此Http
1.0中的队头阻塞发生在 <strong>客户端</strong> ，请求阻塞。</p></li>
</ul></li>
<li><h2 id="http-1.1">Http 1.1</h2>
<ul>
<li><h3 id="默认长连接">默认长连接</h3>
<p>  Http 1.1默认持久连接，TCP连接不关闭。</p></li>
<li><h3 id="管道化">管道化</h3>
<p>  管道化技术解决了Http
1.0中的客户端队头阻塞。管道化技术允许不用等待上一个响应，<strong>直接发送请求</strong>，但是只有
<strong>GET</strong> 和 <strong>HEAD</strong> 请求才能管道化。<br />
  服务器FIFO原则下，<strong>响应的发送要根据 接收的请求的顺序
来排队</strong>，也就是 <strong>先接收</strong> 到的请求，
<strong>先发送</strong> 响应。<br />
  目前浏览器默认关闭管道化。</p></li>
<li><h4 id="管道化下的-http1.1-队头阻塞">管道化下的 Http1.1
队头阻塞</h4>
<p>  因为服务器的FIFO原则，如果先到的请求处理时间长没完成，其他的后续请求已近处理完成并生成了响应，那么已生成的响应就阻塞，必须等到先到请求的响应发送。Http
1.1中的队头阻塞发生在 <strong>服务器端</strong> ，响应阻塞。<br />
  一个 <strong>域名支持多个长连接</strong>
，也就相当于多个任务队列，通过多个任务队列可以减小队头阻塞后续的影响。因为发生队头阻塞，也只有其中一个长连接受影响。</p></li>
</ul></li>
<li><h2 id="http-2">Http 2</h2>
<ul>
<li><h3 id="二进制传输">二进制传输</h3>
<p>  Http 2中，以二进制格式传输，而不是文本格式。将请求和响应
<strong>分割为帧</strong> ，并以二进制表示。Http
2中，同域名下的所有请求响应都是在 <strong>一个连接</strong>
下完成，一个连接可以有 <strong>任意数量的双向数据流</strong>
。帧可以乱序发送，通过帧首部的流标识重新组装。</p></li>
<li><h3 id="多路复用">多路复用</h3>
<p>  完全多路复用，允许一个连接中客户端和服务器端发送多个请求或响应，不用
<strong>顺序对应</strong> 。因此解决了Http 1.1中的队头阻塞。<br />
  但是传输时使用TCP，依旧可能发生
<strong>TCP的队头阻塞</strong>。</p></li>
<li><h3 id="报头压缩">报头压缩</h3>
<p>  客户端和服务器端共同维护一个报文头信息表，所有字段都保存在其中。通过发送索引号表示包含的字段，不需要在报文头信息中附上字段，因此可以减少报文头的大小。<br />
  会通过gzip或者compress压缩头信息。</p></li>
<li><h3 id="服务器推送">服务器推送</h3>
<p>  允许服务器端主动向客户端发送资源。</p></li>
</ul></li>
<li><h2 id="http-3">Http 3</h2>
<ul>
<li><h3 id="tcp的队头阻塞">TCP的队头阻塞</h3>
<p>  为了保证TCP的可靠性，如果一个序列号低的包丢失，会等待该包重传。因此整个TCP连接会阻塞，直到丢失的包重传并接收为止。只要是使用TCP传输数据，就可能发生TCP队头阻塞。因此Http
1、Http 2中都可能发生，而且Http
2中同域名下只有一个连接，因此发生TCP队头阻塞时，整个连接都受影响。</p></li>
<li><h3 id="基于udp协议的quic协议">基于UDP协议的QUIC协议</h3>
<p>  QUIC协议为Quick UDP Internet
Connection，是一个使用UDP多路并发传输的
<strong>传输层协议</strong>。</p></li>
</ul></li>
<li><h2
id="http协议在数据传输和接收中干了什么">HTTP协议在数据传输和接收中干了什么</h2>
<p>  http协议，作为应用层协议，数据传输中所指的这个"数据"(不算其他协议头部)，应用层协议的工作主要就是对这个要传输的"数据"的，格式，内容等做规定。像http协议请求格式就是为：</p>
<ul>
<li>请求行，包含 方法，文件路径，发送端的协议版本。<br />
</li>
<li>请求头，包含
客户端的基本信息以及一些传输给服务器端的请求头字段。<br />
</li>
<li>请求体，包含 发送给服务器的数据，像是form-data等。</li>
</ul>
<p>  总的来说，Http协议的行为，就是对 要传输/接收的
"数据"做出规定，发送端应该按这个格式这么发，然后接收端应该按照这个格式这么解析。</p></li>
</ul></li>
<li><h1 id="https协议">HTTPS协议</h1>
<p>  在Http和Tcp之间，添加安全协议TLS，就是Https。TLS的前身就是SSL。Https对数据进行加密，且能服务器端身份验证。</p>
<ul>
<li><h2 id="数据加密">数据加密</h2>
<ul>
<li><h3 id="共享密钥加密">共享密钥加密</h3>
<p>  共享密钥加密也叫做 <strong>对称密钥加密</strong>
，就是客户端和服务器端都是用同一把密钥对数据进行加密解密。优点是处理快。缺点是
<strong>使用共享的密钥就必须先将该密钥传给对方</strong>
，该过程是不安全的，如果第三方在传输过程中获得了密钥，那数据加密也没了意义。</p></li>
<li><h3 id="公开密钥加密">公开密钥加密</h3>
<p>  公开密钥加密也叫做 <strong>非对称密钥加密</strong>
，就是加密和解密的密钥不是同一把，称为 <strong>公钥</strong> 和
<strong>私钥</strong> 。<br />
  公钥是任何人都可以获得的，私钥是不能给别人的。将公钥传给对方，数据使用公钥加密，然后将加密后的数据使用私钥解密，通过
<strong>数字证书</strong>
来验证公钥的真实性。优点是即使获得了公钥也不能解密数据。缺点是和共享密钥加密相比，处理更复杂也更慢。</p></li>
<li><h3 id="https使用混合加密方式">Https使用混合加密方式</h3>
<p>  首先通过公开密钥加密，对将要使用的共享密钥加密，来保证共享密钥传输时的安全性。后续的通信使用共享密钥加密来保证数据的安全性。</p></li>
</ul></li>
<li><h2 id="tls-的握手过程">TLS 的握手过程</h2>
<p>  TLS的四次握手建立在TCP三次握手之上。因此Https需要先是TCP的三次握手，然后是TLS的四次握手，共七次握手。<br />
<img src="/assets/posts_jpg/TcpIp/TLS握手过程.jpg"
alt="TLS 握手过程" /></p>
<ul>
<li><h3 id="第一次握手-客户端发起请求">第一次握手 客户端发起请求</h3>
<p>  由客户端发起，发送Client Hello消息。消息中包含：客户端生成的
<strong>随机字符串X</strong>，客户端
<strong>支持的加密算法列表</strong>，客户端
<strong>支持的压缩算法列表</strong> ，客户端的
<strong>TLS协议版本</strong> 。</p></li>
<li><h3 id="第二次握手-服务器端回应">第二次握手 服务器端回应</h3>
<p>  服务器接收到客户端的Hello消息后，回应Server
Hello消息。消息中包含：服务器端生成的 <strong>随机字符串Y</strong> ，且
<strong>选择</strong>
后续使用的加密算法、压缩算法、协议版本等。发送Certificate消息，也就是服务器证书。最后Server
Hello Done表示回应结束。</p></li>
<li><h3 id="第三次握手-客户端回应">第三次握手 客户端回应</h3>
<p>  客户端收到证书后验证服务器身份，并从证书中获得公钥。生成
<strong>随机字符串Z</strong> 并使用 <strong>公钥加密</strong>
，发送给服务器端。此时客户端已有随机字符串X，Y，Z，通过
<strong>随机字符串和协商的加密算法</strong> 生成
<strong>共享密钥</strong> ，也就是对称密钥加密中使用的密钥。Change
Cipher
Spec表示告诉服务器端，客户端已经切换到共享密钥加密状态。最后发送Finished消息，表示结束TLS握手。</p></li>
<li><h3 id="第四次握手-服务器端结束回应">第四次握手
服务器端结束回应</h3>
<p>  服务器端收到通过公钥加密的随机字符串Z后，使用私钥解密。此时服务器端有随机字符串X，Y，Z。通过协商好的加密算法和随机字符串生成
<strong>共享密钥</strong>。Change Cipher
Spec表示服务器端已经切换到使用共享密钥加密状态。最后发送Finished消息，结束TLS握手。</p></li>
</ul></li>
<li><h2 id="证书链">证书链</h2>
<p>  在TLS中，客户端接收到服务器端的证书，要验证证书的合法性。一般浏览器内置了
<strong>信任的根证书</strong>，但是服务器发送过来的证书一般
<strong>不是根证书签发</strong>
的。因此通过证书链的信任关系来判断证书的合法性。<br />
  当客户端收到服务器端发的证书后，如果发现该证书的签发者不是信任的根证书，就会向
<strong>CA</strong> 证书机构请求该 <strong>中间证书</strong>
。在收到中间证书后，判断该中间证书的签发者是否为信任的根证书，以此类推。</p></li>
<li><h2
id="tls协议在数据传输和接收中干了什么">TLS协议在数据传输和接收中干了什么</h2>
<p>  TLS协议是应用层协议，应用层协议的工作主要就是对这个要传输的"数据"的，格式，内容等做规定。TLS在数据传输中，通过四次TLS握手双方协商的加密方式。接下来，客户端会根据TLS协议协商的加密方式，加密要传输的数据。接收端会根据TLS协议协商的加密方式，解密接收到的数据。</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TLS</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 和 UDP 协议</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8D%8F%E8%AE%AE/TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<ul>
<li><h1 id="tcp协议">TCP协议</h1>
<p>  TCP协议：实现两个节点间，数据包的可靠传输、流量控制、阻塞控制等。可以想象成：在网络上给两个节点间建立一个连接。</p>
<ul>
<li><h2 id="可靠传输">可靠传输</h2>
<p>  TCP的可靠传输，建立在 <strong>序列号</strong> 和
<strong>确认应答</strong>
等基础之上，来实现TCP的报文重组、重发控制、重复判断等。</p>
<ul>
<li><h3 id="确认应答">确认应答</h3>
<p>  当发送端的数据到达接收端后，接收端会返回一个通知表示自己接收到，也就是
<strong>ACK</strong> 确认应答。<br />
  当发送端在特定时间内没有收到ACK时，会认为数据包丢失而重传。如果数据包到达，但是ACK丢失，发送端也会认为是数据包丢失而重传，此时就需要序列号来区分重复数据。</p></li>
<li><h3 id="序列号和确认号">序列号和确认号</h3>
<p>  按顺序将发送的每一个 <strong>字节</strong> 都标上编号，也就是
<strong>序列号</strong> 。接收端会将 <strong>下一步要接收</strong>
的起始序号写在确认应答的报文中，表示该序号之前的都接收完毕，下一次应该从该序号开始发送，也就是
<strong>确认号</strong> 。<br />
  在发送接收正常的情况下，ACK中确认号一般是， 接收端
<strong>已收到的序列号中最大值+1</strong> 。</p></li>
<li><h3 id="超时重发">超时重发</h3>
<p>  在特定时间内发送端没有收到ACK，就会将数据重发。随着网络环境的变化，该特定时间也不同。在
<strong>每次发包</strong> 时都会计算 <strong>往返时间RTT</strong> 和
RTT的抖动值。超时重发的特定时间就是比 RTT + 偏差
的和要大一些的值。</p></li>
</ul></li>
<li><h2 id="tcp数据传输">TCP数据传输</h2>
<ul>
<li><h3 id="最大消息长度">最大消息长度</h3>
<p>  在建立TCP连接时，可以确定发送一次数据的最大字节数，也就是
<strong>最大消息长度 MSS</strong>
。TCP传输数据时，将数据以MSS的大小进行分割发送，因此TCP是以
<strong>段</strong> 为单位发送数据。<br />
  在三次握手时，通过TCP报文首部写入MSS值，发送端和接收端确定MSS的值并使用该值进行传输，该MSS的值不包括TCP报文头，和IP报文头。<br />
<img src="/assets/posts_jpg/TcpIp/TCP发送数据.jpg"
alt="TCP发送数据" /></p></li>
<li><h3 id="通过窗口提高传输效率">通过窗口提高传输效率</h3>
<p>  TCP每发一个段，等待接收ACK。这种传输方式的效率会随着RTT的提高而降低。效率不高。因此通过窗口来提高效率。<br />
<img src="/assets/posts_jpg/TcpIp/TCP窗口.jpg"
alt="TCP窗口提高效率" /><br />
  如上图所示，设窗口大小为3000字节，MSS为1000字节。发送端不需要等待接收端的ACK，可以继续发送。窗口大小就相当于，发送端无需等待ACK就可以继续发送数据的字节的
<strong>最大值</strong>
。图中窗口大小为3个段大小，因此发送端可以直接发送3次数据。</p></li>
<li><h3 id="滑动窗口机制">滑动窗口机制</h3>
<p>  在收到某段的ACK后，表示该段及其之前的数据已被接收，不会需要重发。将窗口移动到该ACK中的序列号位置。这个就是
<strong>滑动窗口机制</strong> 。<br />
<img src="/assets/posts_jpg/TcpIp/TCP滑动窗口.jpg"
alt="TCP窗口提高效率" /><br />
  如图所示，当发送端接收到ACK时，窗口会移动到ACK中序列号的位置。发送端收到了序列号1001的ACK，因此窗口移动到1001的位置，表示1001之前已经发送并被接收。从1001开始发送或者等待已发送段的ACK到达。</p></li>
<li><h3 id="窗口的重发控制">窗口的重发控制</h3>
<p>  在窗口机制下，有两种丢包情况：</p>
<ul>
<li><h4 id="ack丢失">ACK丢失</h4>
<p><img src="/assets/posts_jpg/TcpIp/TCP窗口ACK丢失.jpg"
alt="TCP窗口ACK丢失" /><br />
  当ACK丢失，且出现如图所示的情况时，发送端可以通过
<strong>下一个</strong> ACK确认1001 ~
2000这一段已被接收。当接收到ACK:3001时，表示这之前的数据已接收，也就包括1001
~ 2000这部分。<br />
  即使ACK丢失，也 <strong>可能</strong>
不需要重发数据，也就是通过下一个ACK来确认。如果无法通过下一个ACK确认时，那么就还是超时重传。</p></li>
<li><h4 id="数据丢失">数据丢失</h4>
<p><img src="/assets/posts_jpg/TcpIp/TCP窗口数据包丢失.jpg"
alt="TCP窗口数据包丢失" /><br />
  如图所示，当数据包丢失时，下一个段到达，接收端没有收到自己期望的序列号。因此ACK还是接收端期望的序列号。在发送端收到ACK后，又收到三次
<strong>重复</strong> 的ACK。就会将该ACK的序列号进行重传。<br />
  接收端会按序列号顺序保存已收到的段。重发数据包的ACK中确认号，就是已接收到的序列号最大值+1。</p></li>
</ul></li>
</ul></li>
<li><h2 id="三次握手">三次握手</h2>
<figure>
<img src="/assets/posts_jpg/TcpIp/TCP三次握手.jpg" alt="TCP三次握手" />
<figcaption aria-hidden="true">TCP三次握手</figcaption>
</figure>
<ul>
<li><h3 id="isn初始化序列号">ISN，初始化序列号</h3>
<p>  主机A和主机B之间的TCP连接，相当于A，B的ip和端口构成的
<strong>四元组</strong>
。如果每次建立连接的初始序列号相同，当A和B之间的连接意外中断，再次连接且是相同四元组时，那么接收端就会出现序列号重复且乱序的情况。恶意攻击可以通过ip，端口，序列号，伪造身份来破坏TCP的正常连接，如果初始序列号每次相同，那么就更容易被攻击。<br />
  因此通过 <strong>初始化序列号</strong>
，使得建立连接的序列号更随机，增加安全性。初始化序列号也就是，增加通信安全的方法之一。</p></li>
<li><h3 id="半连接全连接队列">半连接，全连接队列</h3>
<ul>
<li>半连接队列
：也就是SYN队列。当接收端收到SYN后，会将该连接相关信息保存在半连接队列。<br />
</li>
<li>全接连队列
：也就是accept队列。当接收端收到ACK后，会将该连接从半连接队列中移除，并创建新的全连接保存在全连接队列。通过Socket的accept()，将连接从全连接队列中取出。<br />
</li>
<li>半连接队列溢出
：当半连接队列已满时，发送端的SYN报文就会被丢弃。如果攻击者一直发送SYN包且不发送ACK包，那么接收端就会有大量处于SYN_RCVD的TCP连接，从而导致半连接队列溢出。接收端可以开启
<strong>tcp_syncookies</strong> 防御SYN攻击。<br />
</li>
<li>全连接队列溢出 ：当全连接队列已满时。接收端 <strong>默认</strong>
会丢弃发送端的ACK包。此时，发送端处于 ESTABLISHED 状态，接收端依然处于
SYN_RCVD 状态，发送端此时发送数据也不会得到接收端回应。而接收端会重发
SYN+ACK 包，重发次数超过 <strong>tcp_synack_retries</strong> 后，会发送
<strong>RST</strong> 给发送端重置连接。</li>
</ul>
<p>  除了上面说的默认行为：丢弃ACK包，然后接收端重发 SYN+ACK
包之外，另一种是，当接收端收到ACK包后，直接发送 <strong>RST</strong>
重置连接。总的来说，如果全连接队列满了，tcp连接溢出，会导致
<strong>服务器请求数量上不去</strong>
。被丢弃的TCP连接数量会被统计，可以通过查看该数来判断是否发生全连接队列溢出。</p></li>
<li><h3 id="syn攻击防御手段">SYN攻击防御手段</h3>
<ul>
<li><h4 id="开启-tcp_syncookies-功能">开启 tcp_syncookies 功能</h4>
<p>  SYN攻击点在于服务器的 <strong>资源有限</strong>
。当收到SYN包后，接收端需要分配资源保存该次连接的信息，如四元组，MSS，时间戳等。<br />
  tcp_syncookies的关键在于 <strong>完成三次握手前，不分配资源</strong>
。在接收端不分配资源的情况下，完成握手建立连接。也就是说，接收端要在没有四元组，序列号等信息的情况下，验证发送端的
<strong>ACK包的有效性</strong> 。<br />
  在 <strong>开启</strong>
tcp_syncookies的情况下，初始化序列号的规则会以：5位 时间戳，3位
MSS选项值，24位 四元组和时间戳加密后的hash值
来创建。因此接收端收到ACK后，将第三次握手的包ack-1，就获得了第二次握手的序列号。此时在将四元组和时间戳加密后的hash值，与该序列号后24位进行比较，来验证有效性。<br />
  由此看来，该功能 <strong>缺点</strong>
很明显，1.增加了接收端加密解密运算。2.MSS只有3位选项值，也就是说只有8种MSS值可选。</p></li>
<li><h4 id="增加半连接队列大小">增加半连接队列大小</h4>
<p>  通过增加半连接队列大小，来接收更多的SYN请求。半连接队列大小最大值为
max_qlen_log ，该值受 max_syn_backlog 的值的影响。</p></li>
<li><h4 id="减少接收端-synack包-的重传次数">减少接收端 SYN+ACK包
的重传次数</h4>
<p>  通过修改tcp_synack_retries的值，来减少重传SYN+ACK包次数，可以更快发送
RST 来中断连接。</p></li>
</ul></li>
<li><h3 id="同时建立连接">同时建立连接</h3>
<figure>
<img src="/assets/posts_jpg/TcpIp/TCP同时建立连接.jpg"
alt="TCP同时建立连接" />
<figcaption aria-hidden="true">TCP同时建立连接</figcaption>
</figure>
<ul>
<li><h4 id="状态转换">状态转换</h4>
  待补充</li>
</ul></li>
<li><h3 id="三次握手的必要性">三次握手的必要性</h3>
<p>  三次握手本质上，是数据包传输前，交换两个节点之间所需要的信息。<br />
  TCP的可靠连接，是建立在序列号，确认号上的，而为了安全性，计算机A和计算机B，都会生成初始化序列号。因此，<strong>至少需要两次</strong>
数据传输，才能建立安全可靠的连接，或者说数据传输前的握手，至少需要
计算机A 将自己的初始化序列号传输给 计算机B，以及 计算机B
将自己的初始化序列号传输给 计算机A。<br />
  换个角度说，为了可靠的数据传输，提前告知初始序列号的必要性。TCP会将应用软件产生的数据包分段发送，而因为网络问题，发送顺序不一定就是接收顺序。如果没有提前告知接收端初始序列号，而第一个数据包丢失，其他数据包正常接收，接收端是感知不到包丢失的。<br />
  而交换完初始化序列号后的第三次握手，更多的是为了保护服务器的资源。如果只要两次握手，那么服务器在发送自己的初始序列号后，状态就为ESTABLISHED，然后等待客户端发送的请求，导致服务器资源的浪费。在只有两次握手的情况下，如果因为网络问题，导致第一次握手的网络包A没有到达服务器，客户端后又重新发送第一次的网络包B并成功建立连接。后双方断开连接，此时网络包A延迟到达服务器，服务器收到网络包A后，会把该包当作客户端发送的建立连接请求，而发送自己的初始序列号，建立连接。但客户端当前并没有发送第一次握手包，因此不会因为收到服务器的
ACK+SYN 报文，而建立连接。从而导致服务器资源浪费。</p></li>
</ul></li>
<li><h2 id="四次挥手">四次挥手</h2>
<figure>
<img src="/assets/posts_jpg/TcpIp/TCP四次挥手.jpg" alt="TCP四次挥手" />
<figcaption aria-hidden="true">TCP四次挥手</figcaption>
</figure>
<ul>
<li><h3 id="msl">MSL</h3>
<p>  MSL，也就是段的最长 <strong>寿命</strong>
。换句话说，段在网络中存活的最长时间，超过这个时间的段会被丢弃。<br />
  如果发送端的ACK包丢失，接收端没有收到ACK，到达超时重传的时间后，会重传FIN+ACK包。从发送端的角度，有发送的ACK的MSL及可能重发的FIN+ACK的MSL。因此发送端要等待2MSL的原因为：1.保证能接收到重发的FIN+ACK包。2.保证该次连接中产生的段失效。<br />
  如果ACK一直失效，而接收端一直重发FIN+ACK包的话，经过
<strong>tcp_fin_timeout</strong> 后，断开连接。该值也就是发送端保持在
FIN_WAIT_2 状态的时间。</p></li>
<li><h3 id="同时断开连接">同时断开连接</h3>
<figure>
<img src="/assets/posts_jpg/TcpIp/TCP同时断开连接.jpg"
alt="TCP同时断开连接" />
<figcaption aria-hidden="true">TCP同时断开连接</figcaption>
</figure>
<ul>
<li><h4 id="状态转换-1">状态转换</h4>
  待补充</li>
</ul></li>
</ul></li>
<li><h2 id="流量控制">流量控制</h2></li>
<li><h2 id="阻塞控制">阻塞控制</h2></li>
<li><h2
id="tcp协议在数据传输和接收中干了什么">TCP协议在数据传输和接收中干了什么</h2>
<p>  TCP头部控制信息，记录发送端 及 接收端
端口号，以及包的序列号，确认号等，加上ip 协议头部的，发送端 及 接收端
ip地址，能让数据传输的 发送端，接收端 直到对方的 端口号，和
ip地址。的同时能够，让 数据传输时的发送端 知道
接收端接收到哪了，结合发送端自己发送到哪了，来实现 丢失的包的发现 及
重传等。</p></li>
</ul></li>
<li><h1 id="udp协议">UDP协议</h1>
<ul>
<li><h2 id="udp协议-1">UDP协议</h2>
<p>  只关注发送数据，也就是 只加上 端口号。</p></li>
<li><h2 id="kcp协议">KCP协议</h2></li>
<li><h2 id="quic协议">QUIC协议</h2></li>
<li><h2
id="udp协议在数据传输和接收中干了什么">UDP协议在数据传输和接收中干了什么</h2>
<p>  UDP头部控制信息，记录发送端 及 接收端 端口号，加上ip
协议头部的，发送端 及 接收端 ip地址，能让数据传输的 发送端，接收端
直到对方的 端口号，和 ip地址。<br />
  UDP不像TCP一样，报文的切片和重组，因此需要使用UDP传输大文件时，需要在应用层的程序中，先对传输文件进行切割，使得每一个传输的报文
在UDP可传输 范围以内。</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
</search>
